//  Orus Language Project
//  ---------------------------------------------------------------------------
//  File: src/compiler/backend/codegen/peephole.c
//  Author: Jordy Orel KONDA
//  Copyright (c) 2025 Jordy Orel KONDA
//  License: MIT License (see LICENSE file in the project root)
//  Description: Implements peephole optimization passes that simplify generated bytecode sequences.

#include "compiler/codegen/peephole.h"

#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "compiler/bytecode_utils.h"
#include "compiler/compiler.h"
#include "vm/vm.h"
#include "vm/vm_constants.h"

// Disable all debug output for clean program execution
#define PEEPHOLE_DEBUG 0
#if PEEPHOLE_DEBUG == 0
#define printf(...) ((void)0)
#endif

// Global context for tracking statistics
static PeepholeContext peephole_stats;

typedef struct {
    bool known;
    uint8_t opcode;
    uint16_t constant_index;
} RegisterConstant;

typedef enum {
    INSTR_OTHER,
    INSTR_LOAD_IMMEDIATE,
    INSTR_LOAD_BOOL,
    INSTR_MOVE,
} PeepholeInstructionKind;

typedef struct {
    PeepholeInstructionKind kind;
    uint8_t opcode;
    uint8_t dst;
    uint8_t src;
    uint16_t constant_index;
    size_t length;
} PeepholeInstruction;

static void reset_register_state(RegisterConstant* state) {
    if (!state) return;
    memset(state, 0, sizeof(RegisterConstant) * VM_MAX_REGISTERS);
}

static void propagate_register(RegisterConstant* state, uint16_t dst, uint16_t src) {
    if (!state || dst >= VM_MAX_REGISTERS) return;
    if (src < VM_MAX_REGISTERS && state[src].known) {
        state[dst] = state[src];
    } else {
        state[dst].known = false;
    }
}

static bool can_eliminate_load(const RegisterConstant* state, uint8_t reg,
                               uint8_t opcode, uint16_t constant_index) {
    if (!state) {
        return false;
    }
    return state[reg].known && state[reg].opcode == opcode &&
           state[reg].constant_index == constant_index;
}

static void remember_constant(RegisterConstant* state, uint8_t reg,
                              uint8_t opcode, uint16_t constant_index) {
    if (!state) {
        return;
    }
    state[reg].known = true;
    state[reg].opcode = opcode;
    state[reg].constant_index = constant_index;
}

static uint16_t read_u16(const BytecodeBuffer* bytecode, size_t offset) {
    if (!bytecode || offset + 1 >= (size_t)bytecode->count) {
        return 0;
    }
    return (uint16_t)((bytecode->instructions[offset] << 8) |
                      bytecode->instructions[offset + 1]);
}

static bool decode_instruction(const BytecodeBuffer* bytecode, size_t offset,
                               PeepholeInstruction* out) {
    if (!bytecode || !out || offset >= (size_t)bytecode->count) {
        return false;
    }

    size_t length = bytecode_instruction_length(bytecode, offset);
    if (length == 0 || offset + length > (size_t)bytecode->count) {
        return false;
    }

    out->opcode = bytecode->instructions[offset];
    out->length = length;
    out->kind = INSTR_OTHER;
    out->dst = 0;
    out->src = 0;
    out->constant_index = 0;

    switch (out->opcode) {
        case OP_LOAD_FALSE:
        case OP_LOAD_TRUE:
            if (length < 2) {
                return false;
            }
            out->kind = INSTR_LOAD_BOOL;
            out->dst = bytecode->instructions[offset + 1];
            out->constant_index = (out->opcode == OP_LOAD_TRUE) ? 1 : 0;
            break;
        case OP_LOAD_CONST:
        case OP_LOAD_I32_CONST:
        case OP_LOAD_I64_CONST:
        case OP_LOAD_F64_CONST:
            if (length < 4) {
                return false;
            }
            out->kind = INSTR_LOAD_IMMEDIATE;
            out->dst = bytecode->instructions[offset + 1];
            out->constant_index = read_u16(bytecode, offset + 2);
            break;
        case OP_MOVE:
        case OP_MOVE_I32:
        case OP_MOVE_I64:
        case OP_MOVE_F64:
            if (length < 3) {
                return false;
            }
            out->kind = INSTR_MOVE;
            out->dst = bytecode->instructions[offset + 1];
            out->src = bytecode->instructions[offset + 2];
            break;
        default:
            break;
    }

    return true;
}

static bool run_unified_peephole(CompilerContext* ctx) {
    if (!ctx || !ctx->bytecode) {
        return false;
    }

    BytecodeBuffer* bytecode = ctx->bytecode;
    if (bytecode->count <= 0) {
        return false;
    }

    size_t original_count = (size_t)bytecode->count;
    uint8_t* scratch_instructions = malloc(original_count);
    int* scratch_lines = bytecode->source_lines ? malloc(sizeof(int) * original_count) : NULL;
    int* scratch_columns = bytecode->source_columns ? malloc(sizeof(int) * original_count) : NULL;
    const char** scratch_files = bytecode->source_files ? malloc(sizeof(const char*) * original_count) : NULL;

    if (!scratch_instructions || (bytecode->source_lines && !scratch_lines) ||
        (bytecode->source_columns && !scratch_columns) ||
        (bytecode->source_files && !scratch_files)) {
        free(scratch_instructions);
        free(scratch_lines);
        free(scratch_columns);
        free(scratch_files);
        return false;
    }

    RegisterConstant register_state[VM_MAX_REGISTERS];
    reset_register_state(register_state);

    size_t read_offset = 0;
    size_t write_offset = 0;
    bool changed = false;

    while (read_offset < original_count) {
        PeepholeInstruction inst;
        if (!decode_instruction(bytecode, read_offset, &inst)) {
            size_t remaining = original_count - read_offset;
            memcpy(scratch_instructions + write_offset, bytecode->instructions + read_offset, remaining);
            if (scratch_lines) {
                memcpy(scratch_lines + write_offset, bytecode->source_lines + read_offset,
                       remaining * sizeof(int));
            }
            if (scratch_columns) {
                memcpy(scratch_columns + write_offset, bytecode->source_columns + read_offset,
                       remaining * sizeof(int));
            }
            if (scratch_files) {
                memcpy(scratch_files + write_offset, bytecode->source_files + read_offset,
                       remaining * sizeof(const char*));
            }
            write_offset += remaining;
            break;
        }

        size_t consumed = inst.length;
        size_t emitted = inst.length;
        const uint8_t* emit_source = bytecode->instructions + read_offset;
        uint8_t modified_bytes[9];
        bool use_modified = false;

        switch (inst.kind) {
            case INSTR_LOAD_BOOL:
            case INSTR_LOAD_IMMEDIATE: {
                bool eliminated = false;
                bool fused = false;

                if (can_eliminate_load(register_state, inst.dst, inst.opcode, inst.constant_index)) {
                    eliminated = true;
                    emitted = 0;
                    peephole_stats.constant_propagations++;
                    changed = true;
                } else if (inst.opcode == OP_LOAD_I32_CONST) {
                    PeepholeInstruction next;
                    if (decode_instruction(bytecode, read_offset + inst.length, &next) &&
                        next.kind == INSTR_MOVE && next.opcode == OP_MOVE_I32 && next.src == inst.dst) {
                        fused = true;
                        consumed += next.length;
                        emitted = inst.length;
                        use_modified = true;
                        modified_bytes[0] = inst.opcode;
                        modified_bytes[1] = next.dst;
                        modified_bytes[2] = bytecode->instructions[read_offset + 2];
                        modified_bytes[3] = bytecode->instructions[read_offset + 3];
                        remember_constant(register_state, next.dst, inst.opcode, inst.constant_index);
                        peephole_stats.load_move_fusions++;
                        changed = true;
                    }
                }

                if (!eliminated && !fused) {
                    remember_constant(register_state, inst.dst, inst.opcode, inst.constant_index);
                }

                if (fused) {
                    // Preserve original load metadata for the emitted bytes.
                    emit_source = bytecode->instructions + read_offset;
                }
                break;
            }
            case INSTR_MOVE:
                if (inst.dst == inst.src) {
                    emitted = 0;
                    peephole_stats.redundant_moves++;
                    changed = true;
                } else {
                    propagate_register(register_state, inst.dst, inst.src);
                }
                break;
            case INSTR_OTHER:
            default:
                reset_register_state(register_state);
                break;
        }

        if (consumed > emitted) {
            peephole_stats.instructions_eliminated += (int)(consumed - emitted);
        }

        if (emitted > 0) {
            if (use_modified) {
                memcpy(scratch_instructions + write_offset, modified_bytes, emitted);
            } else {
                memcpy(scratch_instructions + write_offset, emit_source, emitted);
            }

            if (scratch_lines) {
                memcpy(scratch_lines + write_offset, bytecode->source_lines + read_offset,
                       emitted * sizeof(int));
            }
            if (scratch_columns) {
                memcpy(scratch_columns + write_offset, bytecode->source_columns + read_offset,
                       emitted * sizeof(int));
            }
            if (scratch_files) {
                memcpy(scratch_files + write_offset, bytecode->source_files + read_offset,
                       emitted * sizeof(const char*));
            }
            write_offset += emitted;
        }

        read_offset += consumed;
    }

    if (changed) {
        memcpy(bytecode->instructions, scratch_instructions, write_offset);
        if (scratch_lines) {
            memcpy(bytecode->source_lines, scratch_lines, write_offset * sizeof(int));
        }
        if (scratch_columns) {
            memcpy(bytecode->source_columns, scratch_columns, write_offset * sizeof(int));
        }
        if (scratch_files) {
            memcpy(bytecode->source_files, scratch_files, write_offset * sizeof(const char*));
        }
        bytecode->count = (int)write_offset;
    }

    free(scratch_instructions);
    free(scratch_lines);
    free(scratch_columns);
    free(scratch_files);

    return changed;
}

void init_peephole_context(PeepholeContext* ctx) {
    if (!ctx) return;
    ctx->patterns_optimized = 0;
    ctx->instructions_eliminated = 0;
    ctx->load_move_fusions = 0;
    ctx->redundant_moves = 0;
    ctx->constant_propagations = 0;
}

const PeepholeContext* get_peephole_statistics(void) {
    return &peephole_stats;
}

bool apply_peephole_optimizations(CompilerContext* ctx) {
    if (!ctx || !ctx->bytecode) return false;

    printf("[PEEPHOLE] 🔧 Starting peephole optimizations...\n");
    init_peephole_context(&peephole_stats);

    bool changed = run_unified_peephole(ctx);
    peephole_stats.patterns_optimized = peephole_stats.load_move_fusions +
                                       peephole_stats.redundant_moves +
                                       peephole_stats.constant_propagations;

    print_peephole_statistics(&peephole_stats);
    return changed;
}

void print_peephole_statistics(PeepholeContext* ctx) {
    if (!ctx) return;
    printf("[PEEPHOLE] ✅ Peephole optimizations: %d patterns optimized\n", ctx->patterns_optimized);
    printf("[PEEPHOLE] 📊 LOAD+MOVE fusions: %d\n", ctx->load_move_fusions);
    printf("[PEEPHOLE] 📊 Redundant moves eliminated: %d\n", ctx->redundant_moves);
    printf("[PEEPHOLE] 📊 Constant propagations: %d\n", ctx->constant_propagations);
    printf("[PEEPHOLE] 📊 Total instructions eliminated: %d\n", ctx->instructions_eliminated);
}

// Register coalescing function (temporary wrapper)
bool apply_register_coalescing(CompilerContext* ctx) {
    (void)ctx;
    return true;
}
