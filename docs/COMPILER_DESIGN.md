Orus Compiler Design Specification
A Simple, Efficient Compiler for the Orus Register-Based VM with Hindley-Milner Type System
Executive Summary
This document outlines the design for a single-pass compiler that transforms a typed Abstract Syntax Tree (AST), generated by Hindley-Milner (HM) type inference, into optimized bytecode for a 256-register virtual machine (VM). The typed AST is a critical component, enabling efficient single-pass compilation by providing pre-resolved type information, addressing the complexity of a previous attempt that combined HM inference and code generation in one pass. A dedicated visualization tool (typed_ast_visualizer.c) is introduced to debug the typed AST before bytecode generation, ensuring correctness and developer confidence. The design delivers Python-like readability, Rust-like safety, and Lua-like performance, targeting >10,000 lines/second compilation and runtime performance 10x Python and 12x JavaScript.
Table of Contents

Architecture Overview
Design Principles
Component Analysis
Compiler Pipeline
Typed AST Visualization
Register Allocation Strategy
Bytecode Generation
Type System Integration
Optimization Passes
Implementation Plan
Testing Strategy
Performance Expectations
Error Handling Integration
File Structure
Success Criteria
Conclusion

Architecture Overview
Current State Analysis
Existing Components:

✅ Lexer: Comprehensive tokenization with 105+ token types, including type suffixes (e.g., 42i32), strings, and indentation tracking.
✅ Parser: Precedence-climbing parser producing a rich AST with all language constructs.
✅ VM: 256-register VM with 135+ opcodes, supporting type-specific operations and efficient dispatch.
✅ HM Type System: Phase 5 complete, with comprehensive type inference and casting support, producing a typed AST.
❌ Compiler: Missing - this is the implementation target.

Target Architecture:The compiler processes a typed AST, generated by HM type inference, in a single pass to produce bytecode. A visualization tool aids debugging by outputting the typed AST structure. The process is illustrated below:
flowchart TB
  Source --> Lexer --> Parser --> AST
  AST --> HM --> TypedAST
  TypedAST --> Visualizer --> SinglePassCompiler --> Bytecode
  Bytecode --> VM

Integration Points
The compiler integrates with existing systems via:

Input: Typed AST from type_inference.c, where HM type inference annotates each node with types (e.g., i32, f64).
Output: Bytecode arrays for VM execution, stored in a BytecodeBuffer.
Type System: type_representation.c for accessing type information and validating casts.
Error Reporting: Modular error system in src/errors/features/ for Rust-like error messages.
Visualization: typed_ast_visualizer.c for debugging the typed AST before compilation.

Design Principles
1. Simplicity (Lua-Inspired)

Single-pass compilation from typed AST to bytecode minimizes complexity.
Avoids intermediate representations beyond the typed AST.
Visualization of the typed AST simplifies debugging.

2. Performance (Lua-Like)

Targets >10,000 lines/second compilation speed.
Leverages type-specific opcodes (e.g., ADD_I32_R) for runtime efficiency.
Optimizes register usage in the 256-register VM to minimize spills.

3. Safety (Rust-Like)

Uses HM-inferred types in the typed AST for compile-time type safety.
Provides clear, actionable error messages for type mismatches and invalid casts.
Visualization ensures type correctness before bytecode generation.

Component Analysis
Lexer Capabilities (src/compiler/frontend/lexer.c)
Strengths:

Supports 105+ token types, including literals (42i32, "hello"), operators, and keywords.
Efficient keyword lookup and indentation tracking for Python-like syntax.

Integration Notes:

Produces tokens for the parser, which builds the AST consumed by HM type inference.

Parser Capabilities (src/compiler/frontend/parser.c)
Strengths:

Generates a complete AST supporting all Orus constructs (variables, functions, control flow).
Feeds into HM type inference to produce a typed AST.

AST Node Coverage:
// Core language constructs covered:
NODE_PROGRAM, NODE_VAR_DECL, NODE_IDENTIFIER, NODE_LITERAL
NODE_BINARY, NODE_ASSIGN, NODE_PRINT, NODE_CAST
NODE_IF, NODE_WHILE, NODE_FOR_RANGE, NODE_BLOCK
NODE_FUNCTION, NODE_CALL, NODE_RETURN

VM Target (include/vm/vm.h)
Capabilities:

256 registers (R0-R255) with specialized ranges for globals, locals, temporaries, and modules.
135+ opcodes covering arithmetic, memory, control flow, and type operations.
Type-specific operations (e.g., ADD_I32_R, MUL_F64_R) for performance.
Efficient dispatch using computed-goto and switch.

Register Layout:
R0-R63:    Global registers (long-lived variables)
R64-R191:  Frame registers (function locals, parameters)
R192-R239: Temporary registers (expression evaluation)
R240-R255: Module registers (imports/exports)

Key Instruction Categories:

Arithmetic: ADD_I32_R, MUL_F64_R, etc.
Memory: LOAD_CONST_I32, STORE_LOCAL, etc.
Control Flow: JUMP_IF_R, CALL_DIRECT, etc.
Type Operations: CAST_I32_STR, TYPE_CHECK, etc.

Compiler Pipeline
Single-Pass Design
The compiler processes the typed AST, generated by HM type inference, in a single linear traversal to emit bytecode. This design resolves the complexity of a previous attempt that combined HM inference and code generation, which led to convoluted bookkeeping and incomplete type resolution.
Typed AST Generation:

HM Type Inference: Implemented in type_inference.c, this phase traverses the raw AST to resolve types using HM unification. Each node is annotated with its type (e.g., x: i32 for x = 42), producing a typed AST.
Process: Collects type constraints (e.g., x + 24 implies x: i32), unifies them, and assigns concrete types. Handles polymorphism, explicit type annotations (e.g., 42i32), and casts (via as).
Output: A typed AST where each node includes a dataType field (e.g., TYPE_I32, TYPE_F64), enabling the compiler to select type-specific opcodes without further type resolution.
Importance: Pre-resolving types ensures the compiler can operate in a single pass, as all type information is available upfront, avoiding backtracking.

Single-Pass Compilation:

Traverses the typed AST once, allocating registers and emitting bytecode into a BytecodeBuffer.
Uses pre-inferred types to select opcodes (e.g., ADD_I32_R) and validate operations.
Inline optimizations (e.g., peephole) are applied during code generation.

Pipeline:
flowchart TB
  Source --> Lexer --> Parser --> AST
  AST --> HM --> TypedAST
  TypedAST --> Visualizer --> SinglePassCompiler --> Bytecode
  Bytecode --> VM

Example:
x = 42
y = x + 24


HM Type Inference: Produces typed AST: x: i32 = 42, y: i32 = x + 24.
Visualization: Outputs tree structure (see Typed AST Visualization).
Single-Pass Compilation:
x = 42: Allocate R0, emit LOAD_CONST_I32 R0, 42.
y = x + 24: Allocate R1, R192, emit LOAD_CONST_I32 R192, 24; ADD_I32_R R1, R0, R192.


All bytecode generated in one traversal.

Compilation Context
typedef struct CompilerContext {
    TypedASTNode* typed_ast;       // Input from type inference
    RegisterAllocator allocator;   // Manages 256 registers
    int next_temp_register;        // Tracks R192-R239
    int next_local_register;       // Tracks R64-R191
    SymbolTable* symbols;          // Maps variables to registers and types
    ScopeStack* scopes;            // Manages lexical scoping
    BytecodeBuffer bytecode;       // Output buffer for bytecode
    ConstantPool constants;        // Stores constants (e.g., 42, "hello")
    ErrorReporter* errors;         // For Rust-like error reporting
} CompilerContext;

Typed AST Visualization
To aid debugging, a visualization tool (typed_ast_visualizer.c) outputs the typed AST in a human-readable, tree-like format before bytecode generation. This ensures developers can verify type annotations and AST structure, catching issues early.
Purpose:

Debug HM type inference output.
Validate node types and structure before compilation.
Provide a clear, readable representation for developers.

Implementation:

File: src/compiler/backend/typed_ast_visualizer.c
Function: visualize_typed_ast(CompilerContext* ctx, FILE* output)
Output Format: Indented tree with node types, identifiers, and type annotations (e.g., NODE_VAR_DECL: x, type=i32).
Usage: Called after HM type inference, before the single-pass compiler, with output to console or a file (e.g., typed_ast.txt).

Example Visualization:
x = 42
y = x + 24

Output:
Program
  VarDecl: x, type=i32
    Literal: 42, type=i32
  VarDecl: y, type=i32
    Binary: +, type=i32
      Identifier: x, type=i32
      Literal: 24, type=i32

Integration:

Invoked via a debug flag (e.g., --visualize-ast) in the compiler pipeline.
Uses CompilerContext to access the typed AST and type information.
Supports all AST node types (NODE_VAR_DECL, NODE_BINARY, etc.).

Register Allocation Strategy
Register Assignment Strategy

Global Variables (R0-R63): Assigned at compile time for module-level variables, tracked in the SymbolTable.
Function Frame (R64-R191): Parameters (R64-R79) and locals (R80-R191) allocated based on declaration order within function scopes.
Temporaries (R192-R239): Stack-based allocation with reuse for expression evaluation, managed by next_temp_register.

Example Register Allocation
x = 42           // Global: R0
y = x + 24       // Global: R1, Temp: R192 for intermediate
fn foo(a, b) {   // Params: R64, R65
    c = a + b    // Local: R80, Temp: R192 for addition
    return c     // Return via R80
}

Generated Register Usage:
LOAD_CONST_I32 R0, 42                // x = 42
LOAD_CONST_I32 R192, 24              // 24 for y = x + 24
ADD_I32_R R1, R0, R192              // y = x + 24
// foo function
ADD_I32_R R192, R64, R65            // c = a + b
MOVE R80, R192                      // Store in c
RETURN R80                          // return c

Bytecode Generation
Compilation Strategies by Node Type
Variable Declarations (NODE_VAR_DECL)
compile_var_decl(CompilerContext* ctx, TypedASTNode* node) {
    int value_reg = compile_expression(ctx, node->varDecl.initializer);
    int var_reg = allocate_variable_register(ctx, node->varDecl.name);
    emit_instruction(ctx, OP_MOVE, var_reg, value_reg, 0);
    register_symbol(ctx, node->varDecl.name, var_reg, node->dataType);
}

Binary Expressions (NODE_BINARY)
compile_binary(CompilerContext* ctx, TypedASTNode* node) {
    int left_reg = compile_expression(ctx, node->binary.left);
    int right_reg = compile_expression(ctx, node->binary.right);
    int result_reg = allocate_temp_register(ctx);
    Opcode op = select_arithmetic_opcode(node->binary.op, node->dataType);
    emit_instruction(ctx, op, result_reg, left_reg, right_reg);
    return result_reg;
}

Type Casting (NODE_CAST) using as keyword
compile_cast(CompilerContext* ctx, TypedASTNode* node) {
    int src_reg = compile_expression(ctx, node->cast.expression);
    int dst_reg = allocate_temp_register(ctx);
    if (!can_cast(node->cast.fromType, node->cast.toType)) {
        report_invalid_cast_target(ctx->errors, node->location, node->cast.fromType, node->cast.toType);
        return -1;
    }
    Opcode cast_op = get_cast_opcode(node->cast.fromType, node->cast.toType);
    emit_instruction(ctx, cast_op, dst_reg, src_reg, 0);
    return dst_reg;
}

Instruction Selection
Type-Specific Operations:
Opcode select_arithmetic_opcode(const char* op, Type* type) {
    if (strcmp(op, "+") == 0) {
        switch (type->kind) {
            case TYPE_I32: return OP_ADD_I32_R;
            case TYPE_F64: return OP_ADD_F64_R;
            case TYPE_STRING: return OP_STRING_CONCAT;
            default: return OP_INVALID;
        }
    }
    // Similar for -, *, /, etc.
}

Type System Integration
Type Checking During Compilation
The compiler leverages the Phase 5 HM type system, emphasizing the typed AST:

Type Inference:
Implemented in type_inference.c, HM inference resolves types for all expressions and variables.
Collects constraints (e.g., x + 24 implies x: i32), unifies them, and annotates nodes with types (e.g., dataType=TYPE_I32).
Handles explicit annotations (e.g., 42i32), implicit types, and casts via as.


Type Validation: Uses node->dataType to ensure binary operations are compatible.
Cast Insertion: Emits cast instructions (e.g., CAST_I32_F64) for valid as conversions.
Error Reporting: Reports type mismatches via type_errors.c, with Rust-like messages.

Cast Rules Implementation
bool can_cast(Type* from, Type* to) {
    if (is_numeric(from) && is_numeric(to)) return true;  // e.g., i32 -> f64
    if (from->kind == TYPE_BOOL && is_numeric(to)) return true;  // bool -> i32
    if (is_numeric(from) && to->kind == TYPE_BOOL) return true;  // i32 -> bool
    if (to->kind == TYPE_STRING) return true;  // Most types to string
    if (from->kind == TYPE_STRING) return false;  // String to others disallowed
    return false;
}

Optimization Passes
Local Optimizations
1. Peephole Optimization:
// Pattern: LOAD_CONST + immediate use
LOAD_CONST_I32 R192, 5
ADD_I32_R R64, R192, R65
// Optimized: Use immediate forms where available
ADD_I32_IMM R64, R65, 5

2. Register Reuse:
reset_temp_registers(CompilerContext* ctx) {
    ctx->next_temp_register = 192;  // Reset to R192 after expression
}

3. Dead Code Elimination:
// Remove unused assignments
MOVE R192, R64     // Eliminated if R192 unused
ADD_I32_R R65, R66, R67

Control Flow Optimization
Jump Threading:
// Pattern: Chained jumps
JUMP L1
L1: JUMP L2
// Optimized
JUMP L2

Implementation Plan
Phase 1: Core Infrastructure (Week 1)
// Files to create:
src/compiler/backend/compiler.c
src/compiler/backend/register_allocator.c
src/compiler/backend/bytecode_emitter.c
src/compiler/backend/typed_ast_visualizer.c

Deliverables:

Initialize CompilerContext with register allocation, bytecode buffer, and visualization.
Set up integration with type_inference.c and type_representation.c.

Phase 2: Basic Expressions (Week 2)

Compile literals, variables, assignments, and binary operations.
Implement typed AST visualization.Target Test Cases:

x = 42          // literals and assignment
y = x + 24      // variables and arithmetic
print(y)        // function calls

Phase 3: Type System Integration (Week 3)

Implement type-specific opcodes and casting via as keyword.
Validate visualization output for type annotations.Target Test Cases:

x = 42i32       // typed literals
y = x as f64    // explicit casting
z = x + 3.14    // mixed-type with error

Phase 4: Control Flow (Week 4)

Compile if, while, and for constructs with jump instructions.
Visualize control flow nodes in the typed AST.

Phase 5: Functions (Week 5)

Compile function definitions and calls with parameter allocation.
Visualize function nodes and their type signatures.

Phase 6: Optimization (Week 6)

Implement peephole optimization, register reuse, and dead code elimination.
Performance testing to ensure >10,000 lines/second.

Testing Strategy
Unit Tests
// test_typed_ast_visualizer.c
void test_visualize_var_decl() {
    TypedASTNode* node = create_var_decl_node("x", create_literal_node(42, TYPE_I32));
    CompilerContext ctx = init_compiler_context();
    FILE* output = tmpfile();
    visualize_typed_ast(&ctx, output);
    // Verify output contains "VarDecl: x, type=i32"
}

Integration Tests
// tests/compiler/basic_arithmetic.orus
x = 42
y = 24
result = x + y
print(result)
// Expected visualization:
// Program
//   VarDecl: x, type=i32
//     Literal: 42, type=i32
//   VarDecl: y, type=i32
//     Literal: 24, type=i32
//   VarDecl: result, type=i32
//     Binary: +, type=i32
//       Identifier: x, type=i32
//       Literal: 24, type=i32
// Expected bytecode:
LOAD_CONST_I32 R0, 42
LOAD_CONST_I32 R1, 24
ADD_I32_R R2, R0, R1
CALL_DIRECT R192, print, R2

Regression Tests

Verify existing test cases pass with new compiler and visualizer.
Ensure performance benchmarks (7x Python, 11x JavaScript) are maintained.

Performance Expectations
Compilation Speed

Target: >10,000 lines/second.
Measurement: Time from typed AST to bytecode, excluding visualization.
Comparison: Matches or exceeds Python’s compilation speed.

Generated Code Quality

Register Efficiency: <10% spill rate.
Instruction Count: Minimal instructions via peephole optimization.
Runtime Performance: Maintain 7x Python, 11x JavaScript, aiming for 10x and 12x.

Error Handling Integration
Compiler Error Categories
// src/errors/features/compiler_errors.c
void report_register_exhaustion(SourceLocation loc, const char* func);
void report_type_mismatch_binary(SourceLocation loc, const char* op, Type* left, Type* right);
void report_invalid_cast_target(SourceLocation loc, Type* from, Type* to);
void report_undefined_variable(SourceLocation loc, const char* name);

File Structure
src/compiler/
├── backend/
│   ├── compiler.c             // Main compiler logic
│   ├── register_allocator.c   // Register management
│   ├── bytecode_emitter.c     // Bytecode generation
│   ├── typed_ast_visualizer.c // Typed AST visualization
├── frontend/
│   ├── lexer.c                // ✅ Already implemented
│   └── parser.c               // ✅ Already implemented
include/compiler/
├── compiler.h                 // Compiler interface
├── register_allocator.h       // Register allocation API
├── bytecode_emitter.h        // Bytecode emission API
├── typed_ast_visualizer.h    // Visualization API

Success Criteria
Functional Requirements

Compile all existing test cases successfully.
Generate correct bytecode for VM execution.
Produce and visualize typed AST with HM type system.
Provide Rust-like error messages.
Support all AST node types.

Performance Requirements

Compilation speed: >10,000 lines/second (excluding visualization).
Register efficiency: <10% spill rate.
Code quality: Maintain/improve runtime performance (7x Python, 11x JavaScript).
Memory usage: <1MB for typical programs.

Quality Requirements

Zero runtime errors for valid programs.
Clear error messages for invalid programs.
100% test coverage for compiler and visualizer components.
Comprehensive documentation and examples.

Conclusion
The Orus compiler achieves its goals by decoupling HM type inference into a pre-compilation phase, producing a typed AST that enables single-pass compilation. The addition of a typed AST visualizer (typed_ast_visualizer.c) enhances debugging, allowing developers to inspect type annotations and AST structure before bytecode generation. This design resolves the complexity of the previous attempt, delivering Lua-like performance, Rust-like safety, and Python-like readability while meeting performance targets (10x Python, 12x JavaScript).