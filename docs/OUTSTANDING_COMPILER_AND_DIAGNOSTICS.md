# Outstanding Compiler and Diagnostic Work

This document enumerates the critical gaps in the current compiler backend and diagnostic tooling that must be addressed before layering new language features. Items are grouped by subsystem so they can be scheduled and tackled systematically.

## Compiler backend gaps
- **Source mapping for generated bytecode** – `emit_byte_to_buffer` still records `0` for every line and column, so the VM cannot map runtime faults back to source locations. Finish wiring real line/column metadata into `BytecodeBuffer` when emitting instructions.
- **Jump patching infrastructure** – The placeholder helpers (`emit_jump_placeholder` / `patch_jump`) only emit dummy offsets and never patch them, leaving forward jumps fragile. Implement a real patch table so structured control flow can emit correct offsets without bespoke manual patching everywhere.
- **Per-compilation state tracking** – `CompilerContext` still leaves the planned scope stack and error reporter null, preventing fine-grained scope diagnostics and localized error aggregation. Build those facilities and plumb them through statement/expr compilers.
- **Legacy pipeline removal** – `compileProgram` remains a stub that silently succeeds. Retire the legacy entry points or make them forward to the multi-pass pipeline so the interpreter never executes an empty chunk when the new compiler short-circuits.
- **Optimization pass depth** – The peephole optimizer currently skips constant propagation entirely, so redundant loads flow into codegen. Implement the planned propagation to unlock meaningful post-pass cleanups.
- **Type generalization fidelity** – Hindley–Milner generalization ignores the ambient environment (`generalize` drops `env`). Finish the environment walk so polymorphic bindings get proper quantified type variables instead of monotypes.

## Diagnostic tooling gaps
- **Loop context validation** – Control-flow diagnostics still return `true` for every context check; `is_valid_break_continue_context` is a stub until the compiler exposes real loop depth information. Hook it up so `break`/`continue` misuse is caught reliably.
- **Advanced error presentation** – The roadmap still tracks the full “friendly Rust/Elm-style” error shell as outstanding work, including structured multi-section output, suggestion plumbing, and integration across parser/typechecker/runtime. Complete the initiative outlined in the roadmap before expanding the surface area.
- **Variable diagnostics coverage** – Several planned checks (duplicate declarations, use-before-init, refined scope errors, const reassignment, lifetime analysis) remain unchecked in the roadmap because the current compiler architecture cannot yet supply the required symbol data. Address these so variable misuse is surfaced consistently.
