# Outstanding Compiler and Diagnostic Work

This roadmap captures the compiler backend and diagnostic initiatives that are
still outstanding. The checklist below restructures each item into an actionable
implementation plan paired with the validation we need before shipping. The goal
is to unblock actual development work immediately rather than leaving the list
as aspirational bullet points.

## Implementation kickoff focus

1. Complete the compiler instrumentation tasks in `src/compiler/backend` so the
   code generator can emit debuggable, fully patched bytecode.
2. Wire the diagnostic helpers in `src/errors/features` to the concrete loop and
   scope metadata that the compiler will expose.
3. Stand up regression and integration tests under `tests/` (and update the
   Makefile targets) so every deliverable below ships with coverage.

---

## Compiler backend gaps

### Source mapping for generated bytecode ✅

**Current issue (resolved).** `emit_byte_to_buffer` (see
`src/compiler/backend/compiler.c`) previously recorded `0` for both the line and
the column in `BytecodeBuffer`, so the VM could not project runtime faults back
onto source code. Debug stories and diagnostics both suffered as a result. The
buffer now stores real file, line, and column metadata for each emitted byte, so
the VM and diagnostic shell can surface precise locations.

**Implementation steps.**
- [x] Extend the bytecode emission helpers to accept a `SrcLocation`. The
  `bytecode_set_location` / `bytecode_set_synthetic_location` pair now updates
  the active coordinates while `emit_byte_to_buffer` writes line and column
  entries alongside each opcode.
- [x] Thread concrete locations through the code generator by plucking them from
  `TypedASTNode->location` (or the original AST when available) in
  `generate_bytecode_from_ast` and every `compile_*` helper in
  `src/compiler/backend/codegen/codegen.c`.
- [x] When the compiler synthesizes helper instructions (for example, patched
  jumps), mark them with sentinel metadata so downstream tooling can distinguish
  real user code from generated scaffolding. The synthetic helper sets
  coordinates to `-1` / `NULL` to keep instrumentation honest.

**Testing.**
- [ ] Add a targeted unit-style test that compiles a known AST fragment and
  asserts that `ctx->bytecode->source_lines` / `source_columns` mirror the
  expected locations.
- [x] Create integration fixtures under `tests/error_reporting/` that trigger VM
  runtime errors and verify that the diagnostic shell prints real file/line
  information (`runtime_division_by_zero_location`).
- [x] Run `make test` (plus `python3 tests/error_reporting/run_error_tests.py
  ./orus_debug`) to ensure the new metadata does not regress existing tests.

### Jump patching infrastructure ✅

**Resolution.** `emit_jump_placeholder` and `patch_jump` now maintain a
first-class patch table on `BytecodeBuffer`. Each placeholder records the opcode
offset, operand span, and chosen opcode so that forward and backward jumps can be
rewritten without bespoke manual patching. The new infrastructure powers
`compile_if_statement`, `compile_while_statement`, and both `for` compilers.

**Implementation steps.**
- [x] Flesh out the `JumpPatch` bookkeeping inside `BytecodeBuffer` so each
  placeholder records the opcode location, operand span, and eventual target.
- [x] Patch pending entries by computing the relative delta at the moment the
  target offset becomes known, automatically rewriting backward `OP_JUMP`
  placeholders into the matching `OP_LOOP` form when required.
- [x] Update `compile_if_statement`, `compile_while_statement`, and both range /
  iterator `for` compilers in `codegen.c` to allocate placeholders and patch
  them instead of mutating raw instruction bytes.
- [x] Ensure the infrastructure handles both 8-bit (`OP_JUMP_SHORT`) and 16-bit
  (`OP_JUMP`) encodings.

**Testing.**
- [x] Added bytecode-level assertions in
  `tests/unit/test_jump_patch.c` covering conditional, short, and backward jump
  scenarios.
- [x] Added `tests/control_flow/jump_patch_regression.orus` to exercise
  control-flow programs that rely on patched offsets.
- [x] Exposed a `make test-control-flow` target and run it alongside the
  comprehensive suite to cover the control-flow slice.

### Per-compilation state tracking

**Current issue.** `CompilerContext` ships with TODO placeholders for `ScopeStack`
management and for the structured `ErrorReporter`. Without them the compiler
cannot surface scope errors, track loop depth, or aggregate diagnostics.

**Implementation steps.**
- [x] Initialize `ScopeStack` and `ErrorReporter` instances inside
  `init_compiler_context`, and plumb them through the statement and expression
  compilers.
- [x] Teach `compile_block_with_scope` to push/pop lexical scopes so that
  locals, temporaries, and loop nesting depth become observable.
- [x] Replace ad-hoc booleans with explicit helper APIs (`enter_loop_context`,
  `leave_loop_context`) that record `current_loop_start`, `end`, and
  `continue` offsets and publish them to the diagnostic layer.
- [x] Ensure `free_compiler_context` tears down every allocation to avoid
  leaks.

**Testing.**
- Craft parser-level fixtures that declare variables in nested scopes and
  exercise `break`/`continue` to validate the loop depth bookkeeping.
- Add regression tests in `tests/variables/` that would previously pass silently
  when scopes were ignored (duplicate names, shadowing, etc.).
- Extend the diagnostic harness so failing tests assert on the aggregated error
  list, not just success/failure.

### Legacy pipeline removal

**Current issue.** `compileProgram` in
`src/compiler/backend/compiler.c` remains a stub that always returns `true`,
leaving the VM without bytecode when the new pipeline aborts early.

**Implementation steps.**
- Replace the stub with a thin adapter that builds a `CompilerContext` from the
  legacy AST, runs `compile_to_bytecode`, and injects the resulting chunk into
  the VM.
- Remove call sites in `vm.c` that assume the legacy compiler is active, or gate
  them behind a runtime switch that defaults to the multi-pass pipeline.
- When compilation fails, surface the aggregated diagnostics via the
  `ErrorReporter` instead of silently succeeding.

**Testing.**
- Add smoke tests in `tests/comprehensive/` that drive the full VM through the
  CLI entry points (`./orus program.orus`).
- Ensure the interpreter exits with a non-zero status when compilation fails by
  adding shell-based harness checks in `tests/error_reporting/`.
- Run `make test` plus any targeted CLI integration scripts to confirm the VM
  now executes the bytecode produced by the new compiler.

### Optimization pass depth (constant propagation)

**Current issue.** `optimize_constant_propagation` (in
`src/compiler/backend/codegen/peephole.c`) is a stub. As a result constant loads
flow straight into codegen without folding.

**Implementation steps.**
- Implement a small data-flow lattice that records constant values per register
  while scanning the bytecode. When a register holds a known constant, rewrite
  downstream uses to the literal form and eliminate redundant loads.
- Hook the analyzer into the existing peephole pass so it runs after
  load/move fusion and before register coalescing.
- Track statistics in `PeepholeContext` so we can report how many loads were
  folded and whether any instructions were deleted.

**Testing.**
- Build bytecode-focused unit tests that feed in short instruction sequences and
  assert the optimized buffer no longer contains redundant loads.
- Extend arithmetic fixtures in `tests/arithmetic/` to cover constant-heavy
  expressions, then compare execution counts or bytecode dumps to ensure
  propagation triggers.
- Capture before/after timings for representative programs to quantify the
  performance win as required by `docs/AGENTS.md`.

### Type generalization fidelity

**Current issue.** `generalize` in `src/type/type_inference.c` drops the
environment parameter entirely, so type schemes never quantify free variables.
Generic functions therefore get monomorphic types.

**Implementation steps.**
- Implement the classic Hindley–Milner algorithm: walk the environment, collect
  the free type variables in scope, subtract them from the type’s free variables,
  and bind the remainder.
- Update every call site that currently assumes a monomorphic scheme (for
  example, variable declarations and function parameters) to handle bound type
  variables.
- Audit serialization/deserialization of type schemes so the quantified
  variables persist across module boundaries.

**Testing.**
- Add unit tests in `tests/types/` that infer polymorphic identity functions and
  verify they can be instantiated at different concrete types.
- Extend the negative suite in `tests/type_safety_fails/` to ensure the compiler
  still rejects ill-typed programs even with richer generalization.
- Run the entire `tests/types` category to guard against regressions in the type
  inference engine.

---

## Diagnostic tooling gaps

### Loop context validation

**Current issue.** `is_valid_break_continue_context` in
`src/errors/features/control_flow_errors.c` still returns `true` for every call,
so the parser never reports `break` / `continue` misuse.

**Implementation steps.**
- Consume the loop context APIs exposed by `CompilerContext` once the scope work
  above lands. The helper should query the active loop depth and return `false`
  when outside of any loop.
- Ensure parser actions (`parser.c`) call into the helper for every `break` and
  `continue`, and convert failures into structured diagnostics via
  `report_break_outside_loop_error` / `report_continue_outside_loop_error`.

**Testing.**
- Create parser fixtures under `tests/control_flow/conditions` that intentionally
  place `break` and `continue` statements at top level and inside functions
  without loops. The compiler must now emit the correct error codes.
- Add positive fixtures showing legal usage to ensure valid programs still
  compile.

### Advanced error presentation

**Current issue.** The “friendly Rust/Elm-style” error presentation documented in
`docs/ERROR_FORMAT_REPORTING.md` remains unimplemented, leaving diagnostics
without structured multi-section output or actionable suggestions.

**Implementation steps.**
- Finish the renderer that formats errors into the planned header/body/note
  structure, using the location metadata now provided by the compiler.
- Integrate suggestion plumbing so parser, typechecker, and runtime errors can
  attach fix-it hints.
- Thread the renderer through the CLI, REPL, and test harnesses so every error
  path prints the same rich format.

**Testing.**
- Extend the existing diagnostic snapshot tests (or create new ones under
  `tests/error_reporting/`) to capture the full formatted output for a range of
  representative errors.
- Add CLI-based smoke tests that run failing programs and diff their output
  against golden files checked into the repository.

### Variable diagnostics coverage

**Current issue.** Planned checks for duplicate declarations, use-before-init,
const reassignment, and lifetime analysis remain unimplemented because the
compiler has not exposed the necessary symbol metadata.

**Implementation steps.**
- Once scope tracking is in place, have the compiler populate symbol table
  entries with lifecycle information (declaration location, initialization
  status, mutability flags, escape/lifetime markers).
- Implement the diagnostic passes that walk these structures and emit the
  corresponding feature errors (see `src/errors/features`).
- Feed the results into the unified `ErrorReporter` so users get a consolidated
  report.

**Testing.**
- Add fixtures in `tests/variables/` covering each failure mode, along with
  positive variants to guard against false positives.
- Stress-test nested scopes and closures to exercise the lifetime analysis
  branch.
- Run the variable-specific Makefile targets once they are added (per
  `docs/AGENTS.md`) before every commit.

---

Delivering the tasks above will unblock the remaining roadmap items and provide
the diagnostic fidelity needed for the later language features tracked in
`docs/MISSING.md`.
