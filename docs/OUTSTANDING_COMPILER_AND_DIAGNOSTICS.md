# Outstanding Compiler and Diagnostic Work

This roadmap captures the compiler backend and diagnostic initiatives that are
still outstanding. The checklist below restructures each item into an actionable
implementation plan paired with the validation we need before shipping. The goal
is to unblock actual development work immediately rather than leaving the list
as aspirational bullet points.

## Implementation kickoff focus

1. [x] Complete the compiler instrumentation tasks in `src/compiler/backend` so
   the code generator can emit debuggable, fully patched bytecode.
2. [x] Wire the diagnostic helpers in `src/errors/features` to the concrete loop
   and scope metadata that the compiler now exposes.
3. [x] Stand up regression and integration tests under `tests/` (and update the
   Makefile targets) so every deliverable below ships with coverage.

---

## Compiler backend gaps

### Source mapping for generated bytecode ✅

**Current issue (resolved).** `emit_byte_to_buffer` (see
`src/compiler/backend/compiler.c`) previously recorded `0` for both the line and
the column in `BytecodeBuffer`, so the VM could not project runtime faults back
onto source code. Debug stories and diagnostics both suffered as a result. The
buffer now stores real file, line, and column metadata for each emitted byte, so
the VM and diagnostic shell can surface precise locations.

**Implementation steps.**
- [x] Extend the bytecode emission helpers to accept a `SrcLocation`. The
  `bytecode_set_location` / `bytecode_set_synthetic_location` pair now updates
  the active coordinates while `emit_byte_to_buffer` writes line and column
  entries alongside each opcode.
- [x] Thread concrete locations through the code generator by plucking them from
  `TypedASTNode->location` (or the original AST when available) in
  `generate_bytecode_from_ast` and every `compile_*` helper in
  `src/compiler/backend/codegen/codegen.c`.
- [x] When the compiler synthesizes helper instructions (for example, patched
  jumps), mark them with sentinel metadata so downstream tooling can distinguish
  real user code from generated scaffolding. The synthetic helper sets
  coordinates to `-1` / `NULL` to keep instrumentation honest.

**Testing.**
- [x] Add a targeted unit-style test that compiles a known AST fragment and
  asserts that `ctx->bytecode->source_lines` / `source_columns` mirror the
  expected locations.
- [x] Create integration fixtures under `tests/error_reporting/` that trigger VM
  runtime errors and verify that the diagnostic shell prints real file/line
  information (`runtime_division_by_zero_location`).
- [x] Run `make test` (plus `python3 tests/error_reporting/run_error_tests.py
  ./orus_debug`) to ensure the new metadata does not regress existing tests.

### Jump patching infrastructure ✅

**Resolution.** `emit_jump_placeholder` and `patch_jump` now maintain a
first-class patch table on `BytecodeBuffer`. Each placeholder records the opcode
offset, operand span, and chosen opcode so that forward and backward jumps can be
rewritten without bespoke manual patching. The new infrastructure powers
`compile_if_statement`, `compile_while_statement`, and both `for` compilers.

**Implementation steps.**
- [x] Flesh out the `JumpPatch` bookkeeping inside `BytecodeBuffer` so each
  placeholder records the opcode location, operand span, and eventual target.
- [x] Patch pending entries by computing the relative delta at the moment the
  target offset becomes known, automatically rewriting backward `OP_JUMP`
  placeholders into the matching `OP_LOOP` form when required.
- [x] Update `compile_if_statement`, `compile_while_statement`, and both range /
  iterator `for` compilers in `codegen.c` to allocate placeholders and patch
  them instead of mutating raw instruction bytes.
- [x] Ensure the infrastructure handles both 8-bit (`OP_JUMP_SHORT`) and 16-bit
  (`OP_JUMP`) encodings.

**Testing.**
- [x] Added bytecode-level assertions in
  `tests/unit/test_jump_patch.c` covering conditional, short, and backward jump
  scenarios.
- [x] Added `tests/control_flow/jump_patch_regression.orus` to exercise
  control-flow programs that rely on patched offsets.
- [x] Exposed a `make test-control-flow` target and run it alongside the
  comprehensive suite to cover the control-flow slice.

### Per-compilation state tracking

**Current issue.** `CompilerContext` ships with TODO placeholders for `ScopeStack`
management and for the structured `ErrorReporter`. Without them the compiler
cannot surface scope errors, track loop depth, or aggregate diagnostics.

**Implementation steps.**
- [x] Initialize `ScopeStack` and `ErrorReporter` instances inside
  `init_compiler_context`, and plumb them through the statement and expression
  compilers.
- [x] Teach `compile_block_with_scope` to push/pop lexical scopes so that
  locals, temporaries, and loop nesting depth become observable.
- [x] Replace ad-hoc booleans with explicit helper APIs (`enter_loop_context`,
  `leave_loop_context`) that record `current_loop_start`, `end`, and
  `continue` offsets and publish them to the diagnostic layer.
- [x] Ensure `free_compiler_context` tears down every allocation to avoid
  leaks.

**Testing.**
- [x] Craft parser-level fixtures that declare variables in nested scopes and
  exercise `break`/`continue` to validate the loop depth bookkeeping.
- [x] Add regression tests in `tests/variables/` that would previously pass silently
  when scopes were ignored (duplicate names, shadowing, etc.).
- [x] Extend the diagnostic harness so failing tests assert on the aggregated error
  list, not just success/failure.

### Legacy pipeline removal ✅

**Resolution.** `compileProgram` now serves as a real adapter for the
single-pass, multi-phase backend. The function generates the typed AST, builds a
`CompilerContext`, executes the optimization and codegen passes, and streams the
resulting bytecode/metadata into the VM chunk. Failure paths surface
`ErrorReporter` diagnostics through the friendly formatter instead of returning
success.

**Implementation steps.**
- [x] Replace the stub with a thin adapter that builds a `CompilerContext` from
  the legacy AST, runs `compile_to_bytecode`, and injects the resulting chunk
  into the VM.
- [x] Remove call sites in `vm.c` that assume the legacy compiler is active, or
  gate them behind a runtime switch that defaults to the multi-pass pipeline.
- [x] When compilation fails, surface the aggregated diagnostics via the
  `ErrorReporter` instead of silently succeeding.

**Testing.**
- [x] Add smoke tests in `tests/comprehensive/` that drive the full VM through
  the CLI entry points (`./orus program.orus`).
- [x] Ensure the interpreter exits with a non-zero status when compilation fails
  by adding shell-based harness checks in `tests/error_reporting/`.
- [x] Run `make test` to confirm the VM executes the bytecode produced by the
  new compiler (CLI-driven smoke coverage remains tracked separately).

### Optimization pass depth (constant propagation) ✅

**Resolution.** The peephole optimizer now tracks register-local constant state
while scanning bytecode and removes redundant loads when a register already
holds the same literal (including boolean immediates). The pass is wired into
`apply_peephole_optimizations`, exports statistics through
`PeepholeContext.constant_propagations`, and ships with dedicated C-level unit
tests under `tests/unit/test_constant_propagation.c` that exercise both numeric
and boolean folding behaviour via the new `make peephole-tests` harness.

**Testing.**
- Added the constant propagation unit binary to `make test`, alongside the
  existing jump, source map, and scope suites.
- Verified that the optimizer eliminates duplicate `OP_LOAD_I32_CONST` and
  `OP_LOAD_TRUE` sequences without touching unrelated instructions.
- Continued to run the full comprehensive suite via `make test` to ensure no
  regressions surface in end-to-end programs.

### Type generalization fidelity ✅

**Resolution.** Hindley–Milner style generalization now collects free type
variables from both the expression and the ambient environment, quantifies the
difference, and instantiates fresh type variables on lookup. `generalize`
creates proper schemes with bound-variable metadata, and identifier / call sites
use `instantiate_type_scheme` so polymorphic bindings can be reused safely. New
fixtures (`tests/types/polymorphic_identity.orus`) demonstrate successful
polymorphic reuse, while the negative companion in
`tests/type_safety_fails/polymorphic_identity_mismatch.orus` guards against
invalid cross-type arithmetic.

**Testing.**
- Exercised the new positive and negative fixtures through `make test`, ensuring
  polymorphic code type-checks and ill-typed combinations still fail.
- Re-ran the broader `tests/types` catalogue via the standard test harness to
  confirm previously passing programs continue to compile and execute.

---

## Diagnostic tooling gaps

### Loop context validation ✅

**Resolution.** `is_valid_break_continue_context` now bridges the parser and the
multi-pass compiler scope stack so invalid `break` / `continue` usage is caught
immediately. The helper consults the active `ScopeStack` when a
`CompilerContext` is live and falls back to parser-managed loop depth during
syntactic analysis, matching the single-pass workflow described in the
architecture notes.

**Implementation steps.**
- [x] Consume the loop context APIs exposed by `CompilerContext` once the scope
  work above lands. The helper now queries the active loop depth and returns
  `false` when outside of any loop.
- [x] Ensure parser actions (`parser.c`) call into the helper for every `break`
  and `continue`, converting failures into structured diagnostics via
  `report_break_outside_loop` / `report_continue_outside_loop`.

**Testing.**
- [x] Added diagnostic regression fixtures under `tests/error_reporting/` for
  both `break` and `continue` misuse, ensuring the CLI surfaces the control-flow
  errors with the expected messaging.
- [x] Add positive fixtures showing legal usage to ensure valid programs still
  compile (`loop_control_valid`).

### Advanced error presentation

**Current issue.** The “friendly Rust/Elm-style” error presentation documented in
`docs/ERROR_FORMAT_REPORTING.md` remains unimplemented, leaving diagnostics
without structured multi-section output or actionable suggestions.

**Implementation steps.**
- Finish the renderer that formats errors into the planned header/body/note
  structure, using the location metadata now provided by the compiler.
- Integrate suggestion plumbing so parser, typechecker, and runtime errors can
  attach fix-it hints.
- Thread the renderer through the CLI, REPL, and test harnesses so every error
  path prints the same rich format.

**Testing.**
- Extend the existing diagnostic snapshot tests (or create new ones under
  `tests/error_reporting/`) to capture the full formatted output for a range of
  representative errors.
- Add CLI-based smoke tests that run failing programs and diff their output
  against golden files checked into the repository.

### Variable diagnostics coverage

**Current issue.** Planned checks for duplicate declarations, use-before-init,
const reassignment, and lifetime analysis remain unimplemented because the
compiler has not exposed the necessary symbol metadata.

**Implementation steps.**
- Once scope tracking is in place, have the compiler populate symbol table
  entries with lifecycle information (declaration location, initialization
  status, mutability flags, escape/lifetime markers).
- Implement the diagnostic passes that walk these structures and emit the
  corresponding feature errors (see `src/errors/features`).
- Feed the results into the unified `ErrorReporter` so users get a consolidated
  report.

**Testing.**
- Add fixtures in `tests/variables/` covering each failure mode, along with
  positive variants to guard against false positives.
- Stress-test nested scopes and closures to exercise the lifetime analysis
  branch.
- Run the variable-specific Makefile targets once they are added (per
  `docs/AGENTS.md`) before every commit.

---

Delivering the tasks above will unblock the remaining roadmap items and provide
the diagnostic fidelity needed for the later language features tracked in
`docs/MISSING.md`.
