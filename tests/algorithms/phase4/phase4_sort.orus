// ==============================
// Orus Sorting Property Testbed
// ==============================
print("== Phase 4: Sorting Property Tests (with Counting) ==")

// ---------- Deterministic RNG ----------
global mut RNG_SEED: i32 = 0x13579BDF

fn srand(seed: i32): RNG_SEED = seed
fn rand_u32() -> i32:
    // LCG: X_{n+1} = (aX + c) mod 2^32  (wrap via i32 overflow)
    RNG_SEED = (RNG_SEED * 1664525) + 1013904223
    return RNG_SEED

fn rand_range(lo: i32, hi: i32) -> i32:
    if hi <= lo: return lo
    span = hi - lo + 1
    r = rand_u32()
    // safe modulo for possibly negative r
    m = r % span
    if m < 0: m = m + span
    return lo + m

fn rand_len(max_len: i32) -> i32:
    v = rand_range(0, max_len)
    return v

fn copy_array(xs):
    mut out = []
    mut i: i32 = 0
    while i < len(xs):
        push(out, xs[i])
        i = i + 1
    return out

fn concat(a, b):
    mut out = []
    mut i: i32 = 0
    while i < len(a): push(out, a[i]); i = i + 1
    i = 0
    while i < len(b): push(out, b[i]); i = i + 1
    return out

fn add_k(xs, k: i32):
    mut out = []
    mut i: i32 = 0
    while i < len(xs):
        push(out, xs[i] + k)
        i = i + 1
    return out

fn split_at(xs, mid: i32):
    mut left = []
    mut right = []
    mut i: i32 = 0
    while i < len(xs):
        if i < mid: push(left, xs[i])
        else: push(right, xs[i])
        i = i + 1
    return [left, right]

// ---------- Oracle merge sort (reference) ----------
fn merge(a, b):
    mut out = []
    mut i: i32 = 0
    mut j: i32 = 0
    while i < len(a) and j < len(b):
        if a[i] <= b[j]:
            push(out, a[i]); i = i + 1
        else:
            push(out, b[j]); j = j + 1
    while i < len(a): push(out, a[i]); i = i + 1
    while j < len(b): push(out, b[j]); j = j + 1
    return out

fn oracle_merge_sort(xs):
    n: i32 = len(xs)
    if n <= 1: return copy_array(xs)
    mid: i32 = n / 2
    parts = split_at(xs, mid)
    left = parts[0]
    right = parts[1]
    sl = oracle_merge_sort(left)
    sr = oracle_merge_sort(right)
    return merge(sl, sr)

// ---------- In-place insertion sort (for demo) ----------
fn insertion_sort(label, values):
    n: i32 = len(values)
    mut i: i32 = 1
    while i < n:
        key = values[i]
        mut j: i32 = i
        while j > 0:
            prev: i32 = j - 1
            if values[prev] <= key: break
            values[j] = values[prev]
            j = j - 1
        values[j] = key
        i = i + 1
    return values

// ---------- Counting sort (frequency table; returns new array) ----------
fn counting_sort(label, values):
    n: i32 = len(values)
    if n <= 1: return copy_array(values)
    mut min_v = values[0]
    mut max_v = values[0]
    mut i: i32 = 1
    while i < n:
        v = values[i]
        if v < min_v: min_v = v
        if v > max_v: max_v = v
        i = i + 1
    range_size: i32 = (max_v - min_v) + 1
    mut counts = []
    mut k: i32 = 0
    while k < range_size: push(counts, 0); k = k + 1
    i = 0
    while i < n:
        idx: i32 = values[i] - min_v
        counts[idx] = counts[idx] + 1
        i = i + 1
    mut out = []
    mut ci: i32 = 0
    while ci < len(counts):
        mut freq: i32 = counts[ci]
        while freq > 0:
            push(out, ci + min_v)
            freq = freq - 1
        ci = ci + 1
    return out

// ---------- Helpers: predicates & checks ----------
fn is_sorted(xs) -> bool:
    mut i: i32 = 1
    while i < len(xs):
        if xs[i - 1] > xs[i]: return false
        i = i + 1
    return true

fn arrays_equal(a, b) -> bool:
    if len(a) != len(b): return false
    mut i: i32 = 0
    while i < len(a):
        if a[i] != b[i]: return false
        i = i + 1
    return true

fn assert_prop(ok: bool, name, algo):
    if ok == false: print("FAIL", algo, "â€”", name)

// ---------- Algorithm registry ----------
const ALG_INSERTION = 1
const ALG_COUNTING  = 2
const ALG_ORACLE    = 3    // reference; also used as differential oracle

fn apply_sort(algo_id: i32, label, xs):
    // Always pass a copy so in-place algos don't mutate test fixtures
    work = copy_array(xs)
    if algo_id == ALG_INSERTION: return insertion_sort(label, work)
    if algo_id == ALG_COUNTING:  return counting_sort(label, work)
    if algo_id == ALG_ORACLE:    return oracle_merge_sort(work)
    // default fallback
    return oracle_merge_sort(work)

// ---------- Property suite for a single algorithm ----------
fn run_sort_properties_once(algo_name, algo_id: i32, xs):
    // expected via oracle
    expected = oracle_merge_sort(xs)

    // 1) length preserved
    got = apply_sort(algo_id, "len", xs)
    assert_prop(len(got) == len(xs), "length preserved", algo_name)

    // 2) sortedness
    assert_prop(is_sorted(got), "non-decreasing order", algo_name)

    // 3) differential equivalence to oracle
    assert_prop(arrays_equal(got, expected), "equals oracle(sorted)", algo_name)

    // 4) idempotence
    got2 = apply_sort(algo_id, "idemp", got)
    assert_prop(arrays_equal(got, got2), "idempotent", algo_name)

    // 5) metamorphic (concat & merge)
    mid: i32 = len(xs) / 2
    parts = split_at(xs, mid)
    left  = parts[0]
    right = parts[1]
    s_left  = apply_sort(algo_id, "m_left", left)
    s_right = apply_sort(algo_id, "m_right", right)
    merged  = merge(s_left, s_right)
    s_all   = apply_sort(algo_id, "m_all", xs)
    assert_prop(arrays_equal(s_all, merged), "concat-merge relation", algo_name)

    // 6) metamorphic (offset): sort(map(+k,xs)) == map(+k, sort(xs))
    k: i32 = rand_range(-7, 7)
    xs_k   = add_k(xs, k)
    s_k    = apply_sort(algo_id, "offA", xs_k)
    s_base = apply_sort(algo_id, "offB", xs)
    s_base_k = add_k(s_base, k)
    assert_prop(arrays_equal(s_k, s_base_k), "offset invariance", algo_name)

// ---------- Generators ----------
fn gen_random_array(max_len: i32, min_v: i32, max_v: i32):
    L = rand_len(max_len)
    mut out = []
    mut i: i32 = 0
    while i < L:
        push(out, rand_range(min_v, max_v))
        i = i + 1
    return out

fn fixed_cases():
    mut cases = []

    // Empty
    push(cases, [])
    // Single
    push(cases, [42])
    // Ascending
    push(cases, [1,2,3,4,5,6])
    // Reversed
    push(cases, [9,7,5,3,1,-1])
    // Duplicates
    push(cases, [4,2,4,1,4,3,2])
    // Negatives mixed
    push(cases, [0,-3,-1,4,2,-3])
    // Nearly sorted
    push(cases, [2,3,4,5,1])
    // All equal
    push(cases, [7,7,7,7,7])
    return cases

// ---------- Runner for one algorithm ----------
fn run_props_for(algo_name, algo_id: i32, random_trials: i32):
    print("-- props:", algo_name, "--")
    // Fixed edge cases
    edge = fixed_cases()
    mut i: i32 = 0
    while i < len(edge):
        run_sort_properties_once(algo_name, algo_id, edge[i])
        i = i + 1

    // Random trials
    mut t: i32 = 0
    while t < random_trials:
        xs = gen_random_array(100, -100, 100)
        run_sort_properties_once(algo_name, algo_id, xs)
        t = t + 1

// ---------- Main ----------
srand(0xCAFEBABE)
run_props_for("insertion_sort (in-place)", ALG_INSERTION, 100)
run_props_for("counting_sort (new array)",  ALG_COUNTING,  100)
// Oracle should of course satisfy its own properties; also serves as control.
run_props_for("oracle_merge_sort (reference)", ALG_ORACLE, 50)

print("== Done: Sorting Property Tests ==")
