// Phase 1 heap sort implementation for the algorithm stress-test suite.
// In-place variant that exercises index arithmetic, parent/child math,
// and nested loops while tracking heapify operations, comparisons,
// swaps, and sift iterations.

print("== Phase 1: Heap Sort (In-Place Max-Heap) Smoke ==")

mut HEAPIFY_CALLS = 0
mut HEAP_COMPARISONS = 0
mut HEAP_SWAPS = 0
mut HEAP_SIFTS = 0
mut HEAP_ACTIVE_COUNT = 0

fn swap(values, i, j):
    if i == j:
        return
    temp = values[i]
    values[i] = values[j]
    values[j] = temp
    HEAP_SWAPS = HEAP_SWAPS + 1

fn sift_down(values, start):
    HEAPIFY_CALLS = HEAPIFY_CALLS + 1
    mut root = start
    while true:
        child = (root * 2) + 1
        if child >= HEAP_ACTIVE_COUNT:
            break

        mut largest = root
        HEAP_COMPARISONS = HEAP_COMPARISONS + 1
        if values[largest] < values[child]:
            largest = child

        right = child + 1
        if right < HEAP_ACTIVE_COUNT:
            HEAP_COMPARISONS = HEAP_COMPARISONS + 1
            if values[largest] < values[right]:
                largest = right

        if largest == root:
            break

        swap(values, root, largest)
        HEAP_SIFTS = HEAP_SIFTS + 1
        root = largest

fn heap_sort(label, values):
    HEAPIFY_CALLS = 0
    HEAP_COMPARISONS = 0
    HEAP_SWAPS = 0
    HEAP_SIFTS = 0

    mut count: i32 = len(values)
    if count <= 1:
        print("heap_sort", label, "heapify_calls:", HEAPIFY_CALLS, "comparisons:", HEAP_COMPARISONS, "swaps:", HEAP_SWAPS, "sifts:", HEAP_SIFTS)
        return values

    mut start: i32 = (count / 2) - 1
    while start >= 0:
        HEAP_ACTIVE_COUNT = count
        sift_down(values, start)
        count = HEAP_ACTIVE_COUNT
        start = start - 1

    mut heap_size: i32 = count
    while heap_size > 1:
        swap(values, 0, heap_size - 1)
        heap_size = heap_size - 1
        HEAP_ACTIVE_COUNT = heap_size
        sift_down(values, 0)
        heap_size = HEAP_ACTIVE_COUNT

    print("heap_sort", label, "heapify_calls:", HEAPIFY_CALLS, "comparisons:", HEAP_COMPARISONS, "swaps:", HEAP_SWAPS, "sifts:", HEAP_SIFTS)
    return values

// === Tests ===
unsorted = [12, 11, 13, 5, 6, 7]
expected_unsorted = [5, 6, 7, 11, 12, 13]
if assert_eq("heap_sort random", heap_sort("random", unsorted), expected_unsorted):
    print("ok", "heap_sort random")

ascending = [1, 2, 3, 4, 5, 6]
if assert_eq("heap_sort already_sorted", heap_sort("already_sorted", ascending), ascending):
    print("ok", "heap_sort already_sorted")

reversed = [9, 7, 5, 3, 1, -1]
expected_reversed = [-1, 1, 3, 5, 7, 9]
if assert_eq("heap_sort reversed", heap_sort("reversed", reversed), expected_reversed):
    print("ok", "heap_sort reversed")

duplicates = [4, 10, 4, 8, 4, 6, 4]
expected_duplicates = [4, 4, 4, 4, 6, 8, 10]
if assert_eq("heap_sort duplicates", heap_sort("duplicates", duplicates), expected_duplicates):
    print("ok", "heap_sort duplicates")

negatives = [0, -2, -5, 3, 2, -1]
expected_negatives = [-5, -2, -1, 0, 2, 3]
if assert_eq("heap_sort negatives", heap_sort("negatives", negatives), expected_negatives):
    print("ok", "heap_sort negatives")

single = [42]
if assert_eq("heap_sort single", heap_sort("single", single), single):
    print("ok", "heap_sort single")

empty: [i32] = []
if assert_eq("heap_sort empty", heap_sort("empty", empty), []):
    print("ok", "heap_sort empty")
