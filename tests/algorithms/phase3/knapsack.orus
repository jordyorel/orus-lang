// Phase 3 0-1 knapsack stress cases contrasting exponential recursion
// against bottom-up dynamic programming with instrumentation on both paths.
print("== Phase 3: 0-1 Knapsack Stress ==")

global mut KNAPSACK_NAIVE_CALLS = 0
global mut KNAPSACK_NAIVE_MAX_DEPTH = 0
global mut KNAPSACK_NAIVE_BRANCH_SPLITS = 0

fn knapsack_naive_inner(index: i32, capacity: i32, weights, values, depth: i32) -> i32:
    KNAPSACK_NAIVE_CALLS = KNAPSACK_NAIVE_CALLS + 1
    if depth > KNAPSACK_NAIVE_MAX_DEPTH:
        KNAPSACK_NAIVE_MAX_DEPTH = depth

    if index >= len(weights) or capacity <= 0:
        return 0

    weight = weights[index]
    value = values[index]

    if weight > capacity:
        return knapsack_naive_inner(index + 1, capacity, weights, values, depth + 1)

    KNAPSACK_NAIVE_BRANCH_SPLITS = KNAPSACK_NAIVE_BRANCH_SPLITS + 1

    include_value = value + knapsack_naive_inner(index + 1, capacity - weight, weights, values, depth + 1)
    exclude_value = knapsack_naive_inner(index + 1, capacity, weights, values, depth + 1)

    if include_value > exclude_value:
        return include_value
    return exclude_value

fn run_knapsack_naive(label, weights, values, capacity: i32) -> i32:
    KNAPSACK_NAIVE_CALLS = 0
    KNAPSACK_NAIVE_MAX_DEPTH = 0
    KNAPSACK_NAIVE_BRANCH_SPLITS = 0

    result = knapsack_naive_inner(0, capacity, weights, values, 0)
    print("knapsack_naive", label, "capacity:", capacity, "value:", result, "calls:", KNAPSACK_NAIVE_CALLS, "max_depth:", KNAPSACK_NAIVE_MAX_DEPTH, "branch_splits:", KNAPSACK_NAIVE_BRANCH_SPLITS)
    return result


global mut KNAPSACK_DP_TABLE_CELLS = 0
global mut KNAPSACK_DP_TRANSITIONS = 0
global mut KNAPSACK_DP_REUSES = 0

fn run_knapsack_dp(label, weights, values, capacity: i32) -> i32:
    KNAPSACK_DP_TABLE_CELLS = 0
    KNAPSACK_DP_TRANSITIONS = 0
    KNAPSACK_DP_REUSES = 0

    item_count: i32 = len(weights)
    rows: i32 = item_count
    cols: i32 = capacity

    mut table: [[i32]] = []
    mut row_index: i32 = 0
    while row_index <= rows:
        mut row: [i32] = []
        mut cap: i32 = 0
        while cap <= cols:
            push(row, 0)
            KNAPSACK_DP_TABLE_CELLS = KNAPSACK_DP_TABLE_CELLS + 1
            cap = cap + 1
        push(table, row)
        row_index = row_index + 1

    mut item: i32 = 1
    while item <= rows:
        weight = weights[item - 1]
        value = values[item - 1]

        mut cap_value: i32 = 0
        while cap_value <= capacity:
            exclude_value = table[item - 1][cap_value]
            if weight > cap_value:
                table[item][cap_value] = exclude_value
                KNAPSACK_DP_REUSES = KNAPSACK_DP_REUSES + 1
            else:
                include_value = value + table[item - 1][cap_value - weight]
                KNAPSACK_DP_TRANSITIONS = KNAPSACK_DP_TRANSITIONS + 1
                if include_value > exclude_value:
                    table[item][cap_value] = include_value
                else:
                    table[item][cap_value] = exclude_value
                    KNAPSACK_DP_REUSES = KNAPSACK_DP_REUSES + 1
            cap_value = cap_value + 1
        item = item + 1

    result = table[rows][capacity]
    print("knapsack_dp", label, "capacity:", capacity, "value:", result, "table_cells:", KNAPSACK_DP_TABLE_CELLS, "transitions:", KNAPSACK_DP_TRANSITIONS, "reuse_writes:", KNAPSACK_DP_REUSES)
    return result


fn validate(label, name, observed: i32, expected: i32):
    message = label + " " + name
    if assert_eq(message, observed, expected):
        print(label, name, "=>", observed)


fn run_case(label, weights, values, capacity: i32, expected: i32):
    naive_value = run_knapsack_naive(label, weights, values, capacity)
    validate(label, "naive", naive_value, expected)
    dp_value = run_knapsack_dp(label, weights, values, capacity)
    validate(label, "dp", dp_value, expected)


weights_small = [2, 3, 4, 5]
values_small = [3, 4, 5, 8]
run_case("baseline", weights_small, values_small, 5, 8)
run_case("tight_capacity", weights_small, values_small, 9, 13)
run_case("zero_capacity", weights_small, values_small, 0, 0)

weights_duplicates = [1, 3, 4, 5, 3]
values_duplicates = [1, 4, 5, 7, 4]
run_case("duplicate_weights", weights_duplicates, values_duplicates, 7, 9)

// Stress the DP table with more items while skipping the exponential naive version.
weights_stress = [5, 10, 15, 22, 25, 7, 9, 13, 17, 19]
values_stress = [10, 30, 25, 50, 70, 15, 18, 22, 28, 33]
stress_capacity = 50
stress_dp_value = run_knapsack_dp("stress", weights_stress, values_stress, stress_capacity)
validate("stress", "dp", stress_dp_value, 128)
