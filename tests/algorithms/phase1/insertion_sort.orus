// Phase 1 insertion sort baseline for the algorithm stress-test suite (in-place).
print("== Phase 1: Insertion Sort (In-Place) Smoke ==")

fn insertion_sort(label, values):
    length = len(values)
    mut pass_count = 0
    mut shifts = 0

    if length <= 1:
        print("insertion_sort", label, "passes:", pass_count, "shifts:", shifts)
        return values

    mut i: i32 = 1
    while i < length:
        pass_count = pass_count + 1
        key = values[i]
        mut j: i32 = i

        while j > 0:
            prev_index: i32 = j - 1
            if values[prev_index] <= key:
                break
            values[j] = values[prev_index]
            shifts = shifts + 1
            j = j - 1

        values[j] = key
        i = i + 1

    print("insertion_sort", label, "passes:", pass_count, "shifts:", shifts)
    return values

// === Tests ===
unsorted = [12, 5, 1, 8, 14, 7]
expected_unsorted = [1, 5, 7, 8, 12, 14]
print("random =>", insertion_sort("random", unsorted), "expected", expected_unsorted)

nearly_sorted = [2, 3, 4, 5, 1]
expected_nearly_sorted = [1, 2, 3, 4, 5]
print("rotation =>", insertion_sort("rotation", nearly_sorted), "expected", expected_nearly_sorted)

with_negatives = [0, -3, -1, 4, 2]
expected_with_negatives = [-3, -1, 0, 2, 4]
print("negatives =>", insertion_sort("negatives", with_negatives), "expected", expected_with_negatives)

duplicates = [4, 2, 4, 2, 4]
expected_duplicates = [2, 2, 4, 4, 4]
print("duplicates =>", insertion_sort("duplicates", duplicates), "expected", expected_duplicates)

short = [3]
print("single =>", insertion_sort("single", short), "expected", short)

empty = []
print("empty =>", insertion_sort("empty", empty), "expected", [])
