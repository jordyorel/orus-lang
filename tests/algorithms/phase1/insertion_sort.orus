// Phase 1 insertion sort baseline for the algorithm stress-test suite (in-place).
print("== Phase 1: Insertion Sort (In-Place) Smoke ==")

fn insertion_sort(label, values):
    length = len(values)
    mut pass_count = 0
    mut shifts = 0

    if length <= 1:
        print("insertion_sort", label, "passes:", pass_count, "shifts:", shifts)
        return values

    mut i: i32 = 1
    while i < length:
        pass_count = pass_count + 1
        key = values[i]
        mut j: i32 = i

        while j > 0:
            prev_index: i32 = j - 1
            if values[prev_index] <= key:
                break
            values[j] = values[prev_index]
            shifts = shifts + 1
            j = j - 1

        values[j] = key
        i = i + 1

    print("insertion_sort", label, "passes:", pass_count, "shifts:", shifts)
    return values

// === Tests ===
unsorted = [12, 5, 1, 8, 14, 7]
expected_unsorted = [1, 5, 7, 8, 12, 14]
if assert_eq("insertion_sort random", insertion_sort("random", unsorted), expected_unsorted):
    print("ok", "insertion_sort random")

nearly_sorted = [2, 3, 4, 5, 1]
expected_nearly_sorted = [1, 2, 3, 4, 5]
if assert_eq("insertion_sort rotation", insertion_sort("rotation", nearly_sorted), expected_nearly_sorted):
    print("ok", "insertion_sort rotation")

with_negatives = [0, -3, -1, 4, 2]
expected_with_negatives = [-3, -1, 0, 2, 4]
if assert_eq("insertion_sort negatives", insertion_sort("negatives", with_negatives), expected_with_negatives):
    print("ok", "insertion_sort negatives")

duplicates = [4, 2, 4, 2, 4]
expected_duplicates = [2, 2, 4, 4, 4]
if assert_eq("insertion_sort duplicates", insertion_sort("duplicates", duplicates), expected_duplicates):
    print("ok", "insertion_sort duplicates")

short = [3]
if assert_eq("insertion_sort single", insertion_sort("single", short), short):
    print("ok", "insertion_sort single")

empty: [i32] = []
if assert_eq("insertion_sort empty", insertion_sort("empty", empty), []):
    print("ok", "insertion_sort empty")
