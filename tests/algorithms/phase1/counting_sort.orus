// Phase 1 counting sort implementation for the algorithm stress-test suite.
// Iterative version that measures range sizing, counting passes, and emission
// volume to stress array indexing, nested loops, and arithmetic on offsets.

print("== Phase 1: Counting Sort (Frequency Table) Smoke ==")

mut COUNTING_EXTENT_SCANS = 0
mut COUNTING_RANGE_SLOTS = 0
mut COUNTING_COUNT_UPDATES = 0
mut COUNTING_OUTPUT_WRITES = 0

fn counting_sort(label: string, values: [i32]):
    COUNTING_EXTENT_SCANS = 0
    COUNTING_RANGE_SLOTS = 0
    COUNTING_COUNT_UPDATES = 0
    COUNTING_OUTPUT_WRITES = 0

    length = len(values)
    if length <= 1:
        print("counting_sort", label, "range_size:", COUNTING_RANGE_SLOTS, "extent_scans:", COUNTING_EXTENT_SCANS, "count_updates:", COUNTING_COUNT_UPDATES, "output_writes:", COUNTING_OUTPUT_WRITES)
        return values

    mut min_value: i64 = values[0] as i64
    mut max_value: i64 = values[0] as i64

    mut i: i32 = 1
    while i < length:
        current: i64 = values[i] as i64
        if current < min_value:
            min_value = current
        if current > max_value:
            max_value = current
        COUNTING_EXTENT_SCANS = COUNTING_EXTENT_SCANS + 1
        i = i + 1

    mut range_size_span: i64 = max_value - min_value
    if range_size_span < (0 as i64):
        print("counting_sort", label, "range_size:", COUNTING_RANGE_SLOTS, "extent_scans:", COUNTING_EXTENT_SCANS, "count_updates:", COUNTING_COUNT_UPDATES, "output_writes:", COUNTING_OUTPUT_WRITES)
        return values

    range_size_span = range_size_span + 1
    if range_size_span > (2147483647 as i64):
        print("counting_sort", label, "range_size:", COUNTING_RANGE_SLOTS, "extent_scans:", COUNTING_EXTENT_SCANS, "count_updates:", COUNTING_COUNT_UPDATES, "output_writes:", COUNTING_OUTPUT_WRITES)
        return values

    range_size: i32 = range_size_span as i32

    COUNTING_RANGE_SLOTS = range_size

    mut counts: [i32] = []
    mut slot: i32 = 0
    while slot < range_size:
        push(counts, 0)
        slot = slot + 1

    mut idx: i32 = 0
    while idx < length:
        value_offset: i32 = ((values[idx] as i64) - min_value) as i32
        counts[value_offset] = counts[value_offset] + 1
        COUNTING_COUNT_UPDATES = COUNTING_COUNT_UPDATES + 1
        idx = idx + 1

    mut output: [i32] = []
    mut count_index: i32 = 0
    while count_index < len(counts):
        mut freq = counts[count_index]
        while freq > 0:
            push(output, ((count_index as i64) + min_value) as i32)
            COUNTING_OUTPUT_WRITES = COUNTING_OUTPUT_WRITES + 1
            freq = freq - 1
        count_index = count_index + 1

    print("counting_sort", label, "range_size:", COUNTING_RANGE_SLOTS, "extent_scans:", COUNTING_EXTENT_SCANS, "count_updates:", COUNTING_COUNT_UPDATES, "output_writes:", COUNTING_OUTPUT_WRITES)
    return output

// === Tests ===
random_values = [4, 2, 2, 8, 3, 3, 1]
expected_random = [1, 2, 2, 3, 3, 4, 8]
if assert_eq("counting_sort random", counting_sort("random", random_values), expected_random):
    print("ok", "counting_sort random")

already_sorted = [1, 2, 3, 4, 5, 6]
if assert_eq("counting_sort already_sorted", counting_sort("already_sorted", already_sorted), already_sorted):
    print("ok", "counting_sort already_sorted")

reversed = [9, 7, 5, 3, 1, -1]
expected_reversed = [-1, 1, 3, 5, 7, 9]
if assert_eq("counting_sort reversed", counting_sort("reversed", reversed), expected_reversed):
    print("ok", "counting_sort reversed")

with_duplicates = [5, 1, 3, 5, 2, 5, 1]
expected_duplicates = [1, 1, 2, 3, 5, 5, 5]
if assert_eq("counting_sort duplicates", counting_sort("duplicates", with_duplicates), expected_duplicates):
    print("ok", "counting_sort duplicates")

with_negatives = [0, -3, -1, 4, 2, -3]
expected_negatives = [-3, -3, -1, 0, 2, 4]
if assert_eq("counting_sort negatives", counting_sort("negatives", with_negatives), expected_negatives):
    print("ok", "counting_sort negatives")

single = [42]
if assert_eq("counting_sort single", counting_sort("single", single), single):
    print("ok", "counting_sort single")

empty = []
if assert_eq("counting_sort empty", counting_sort("empty", empty), []):
    print("ok", "counting_sort empty")
