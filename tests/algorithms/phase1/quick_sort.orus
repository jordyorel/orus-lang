// Phase 1 quick sort implementation for the algorithm stress-test suite.
// Functional variant that returns a new array to stress recursion, pivot
// selection, and dynamic array construction while tracking simple metrics.

global mut QUICK_COMPARISONS = 0
global mut QUICK_PARTITIONS = 0
global mut QUICK_MAX_DEPTH = 0

fn quick_sort_recursive(values, depth):
    length = len(values)
    if depth > QUICK_MAX_DEPTH:
        QUICK_MAX_DEPTH = depth
    if length <= 1:
        return values

    pivot = values[length / 2]
    mut less: [i32] = []
    mut equal: [i32] = []
    mut greater: [i32] = []

    mut i = 0
    while i < length:
        current = values[i]
        QUICK_COMPARISONS = QUICK_COMPARISONS + 1
        if current < pivot:
            push(less, current)
        elif current > pivot:
            QUICK_COMPARISONS = QUICK_COMPARISONS + 1
            push(greater, current)
        else:
            push(equal, current)
        i = i + 1

    QUICK_PARTITIONS = QUICK_PARTITIONS + 1

    sorted_less = quick_sort_recursive(less, depth + 1)
    sorted_greater = quick_sort_recursive(greater, depth + 1)

    mut result: [i32] = []
    mut li = 0
    while li < len(sorted_less):
        push(result, sorted_less[li])
        li = li + 1

    mut ei = 0
    while ei < len(equal):
        push(result, equal[ei])
        ei = ei + 1

    mut gi = 0
    while gi < len(sorted_greater):
        push(result, sorted_greater[gi])
        gi = gi + 1

    return result

fn quick_sort(label, values):
    QUICK_COMPARISONS = 0
    QUICK_PARTITIONS = 0
    QUICK_MAX_DEPTH = 0
    sorted = quick_sort_recursive(values, 1)
    print("quick_sort", label, "comparisons:", QUICK_COMPARISONS, "partitions:", QUICK_PARTITIONS, "max_depth:", QUICK_MAX_DEPTH)
    return sorted

// === Tests ===
unsorted = [33, 10, 55, 71, 29, 3, 18]
expected_unsorted = [3, 10, 18, 29, 33, 55, 71]
if assert_eq("quick_sort random", quick_sort("random", unsorted), expected_unsorted):
    print("ok", "quick_sort random")

ascending = [2, 4, 6, 8, 10]
if assert_eq("quick_sort already_sorted", quick_sort("already_sorted", ascending), ascending):
    print("ok", "quick_sort already_sorted")

reversed = [9, 7, 5, 3, 1, -1]
expected_reversed = [-1, 1, 3, 5, 7, 9]
if assert_eq("quick_sort reversed", quick_sort("reversed", reversed), expected_reversed):
    print("ok", "quick_sort reversed")

duplicates = [4, 2, 4, 1, 4, 3, 2]
expected_duplicates = [1, 2, 2, 3, 4, 4, 4]
if assert_eq("quick_sort duplicates", quick_sort("duplicates", duplicates), expected_duplicates):
    print("ok", "quick_sort duplicates")

single = [99]
if assert_eq("quick_sort single", quick_sort("single", single), single):
    print("ok", "quick_sort single")

empty: [i32] = []
if assert_eq("quick_sort empty", quick_sort("empty", empty), []):
    print("ok", "quick_sort empty")
