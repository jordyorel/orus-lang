print("-- builtin range runtime validation --")

fn collect_i32(iter):
    mut out: [i32] = []
    for value in iter:
        push(out, value as i32)
    return out

fn arrays_equal(left, right) -> bool:
    if len(left) != len(right):
        return false
    mut idx: i32 = 0
    count: i32 = len(left)
    while idx < count:
        left_val: i32 = int(left[idx])
        right_val: i32 = int(right[idx])
        if left_val != right_val:
            return false
        idx = idx + 1
    return true

fn assert_sequence(label, iter, expected):
    actual = collect_i32(iter)
    if arrays_equal(actual, expected):
        print("ok", label, actual)
    else:
        print("FAIL", label, actual, expected)

stop_u32: u32 = 5
assert_sequence("range(stop u32)", range(stop_u32), [0, 1, 2, 3, 4])

start_i32: i32 = 3
stop_i64: i64 = 8
assert_sequence("range(start i32, stop i64)", range(start_i32, stop_i64), [3, 4, 5, 6, 7])

step_u64: u64 = 3
limit_i64: i64 = 20
assert_sequence("range(mixed step u64)", range(2, limit_i64, step_u64), [2, 5, 8, 11, 14, 17])

assert_sequence("range(negative step)", range(9, -5, -4), [9, 5, 1, -3])
assert_sequence("range(empty forward)", range(7, 7), [])
assert_sequence("range(empty descending)", range(1, 5, -2), [])
assert_sequence("range(negative start)", range(-3, 3), [-3, -2, -1, 0, 1, 2])

mut reuse = range(4)
assert_sequence("range reuse first", reuse, [0, 1, 2, 3])
assert_sequence("range reuse second", reuse, [])

