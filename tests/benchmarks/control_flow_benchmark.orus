// Control Flow Performance Benchmark - Orus Language
// Focus on while loops and conditional performance
print("=== Orus Control Flow Performance Benchmark ===")

start_time = time_stamp()

// === PHASE 1: BASIC WHILE LOOPS ===
print("Phase 1: Basic While Loops")

// Simple counting loop
counter = 0
while counter < 100000:
    counter = counter + 1
print("Counter result:", counter)

// Summation loop (avoiding overflow with smaller numbers)
sum: i64 = 0
i = 0
while i < 50000:
    sum = sum + (i as i64)
    i = i + 1
print("Sum result:", sum)

// Multiplication accumulator
product: i64 = 1
j = 1
while j <= 20:
    product = product * (j as i64)
    j = j + 1
print("Product result:", product)

// === PHASE 2: NESTED LOOPS ===
print("Phase 2: Nested Loops")

nested_sum = 0
outer = 0
while outer < 500:
    inner = 0
    while inner < 200:
        nested_sum = nested_sum + 1
        inner = inner + 1
    outer = outer + 1
print("Nested sum result:", nested_sum)

// Matrix-like computation
matrix_result = 0
row = 0
while row < 300:
    col = 0
    while col < 333:
        matrix_result = matrix_result + (row * col)
        col = col + 1
    row = row + 1
print("Matrix result:", matrix_result)

// === PHASE 3: CONDITIONAL PERFORMANCE ===
print("Phase 3: Conditional Performance")

// If-else chains in loops
conditional_sum = 0
k = 0
while k < 100000:
    if k % 5 == 0:
        conditional_sum = conditional_sum + k
    else:
        if k % 3 == 0:
            conditional_sum = conditional_sum + (k * 2)
        else:
            conditional_sum = conditional_sum + 1
    k = k + 1
print("Conditional sum result:", conditional_sum)

// Complex boolean expressions
bool_ops = 0
m = 0
while m < 50000:
    if (m > 100) == true:
        if (m < 40000) == true:
            if (m % 7 == 0) == true:
                bool_ops = bool_ops + 1
    m = m + 1
print("Boolean operations result:", bool_ops)

// === PHASE 4: FIBONACCI SEQUENCE ===
print("Phase 4: Fibonacci Sequence")

fib_n = 35
fib_a = 0
fib_b = 1
fib_i = 2
while fib_i <= fib_n:
    fib_temp = fib_a + fib_b
    fib_a = fib_b
    fib_b = fib_temp
    fib_i = fib_i + 1
print("Fibonacci result:", fib_b)

// === PHASE 5: PRIME NUMBER SIEVE ===
print("Phase 5: Prime Number Sieve")

// Simple prime finding
prime_limit = 10000
prime_count = 0
candidate = 2
while candidate <= prime_limit:
    is_prime = true
    divisor = 2
    while divisor * divisor <= candidate:
        if candidate % divisor == 0:
            is_prime = false
            divisor = candidate  // Break out of inner loop
        else:
            divisor = divisor + 1
    if is_prime == true:
        prime_count = prime_count + 1
    candidate = candidate + 1
print("Prime count result:", prime_count)

// === PHASE 6: STRING OPERATIONS WITH LOOPS ===
print("Phase 6: String Operations with Loops")

// String building simulation (using numbers)
string_sim = 0
char_code = 65  // ASCII 'A'
str_length = 0
while str_length < 10000:
    string_sim = string_sim + char_code
    char_code = char_code + 1
    if char_code > 90:  // ASCII 'Z'
        char_code = 65  // Reset to 'A'
    str_length = str_length + 1
print("String simulation result:", string_sim)

// === PHASE 7: MATHEMATICAL SERIES ===
print("Phase 7: Mathematical Series")

// Pi approximation using Leibniz formula
pi_approx = 0
term = 1
sign = 1
series_i = 0
while series_i < 100000:
    pi_approx = pi_approx + (sign * 1000000 / term)
    sign = -sign
    term = term + 2
    series_i = series_i + 1
pi_result = pi_approx * 4 / 1000000
print("Pi approximation result:", pi_result)

// Square root using Newton's method
sqrt_target = 123456
sqrt_x = sqrt_target / 2
sqrt_iterations = 0
while sqrt_iterations < 10000:
    sqrt_x = (sqrt_x + sqrt_target / sqrt_x) / 2
    sqrt_iterations = sqrt_iterations + 1
print("Square root result:", sqrt_x)

// === FINAL BENCHMARK RESULTS ===
end_time = time_stamp()
total_elapsed = end_time - start_time

print("=== CONTROL FLOW BENCHMARK COMPLETE ===")
print("Total execution time:", total_elapsed)
print("While loops executed: 15+")
print("Nested loops: 2")
print("Conditional operations: 150,000+")
print("Mathematical algorithms: 4")
print("Total iterations: 500,000+")
print("Final benchmark score:", total_elapsed * counter / 1000)
print("=== Orus Control Flow Benchmark Complete ===")