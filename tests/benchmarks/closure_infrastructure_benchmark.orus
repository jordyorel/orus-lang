// Closure infrastructure benchmark for Orus
// Tests the closure data structures and VM performance

// Simple function that could become a closure
fn simple_function(x: i32) -> i32:
    x * 2

// Nested functions (closure-like behavior)
fn make_math_function(base: i32) -> i32:
    fn helper(x: i32) -> i32:
        x + 1
    
    result = helper(base)
    result * 2

// Function that creates and calls multiple nested functions
fn complex_nesting() -> i32:
    fn level1() -> i32:
        fn level2() -> i32:
            fn level3() -> i32:
                42
            level3()
        level2()
    level1()

print("=== Orus Closure Infrastructure Benchmark ===")

start_time = time_stamp()

// Test 1: Simple function calls
print("Test 1: Simple function calls")
mut total1 = 0
for i in 0..10000:
    total1 = total1 + simple_function(i)
print("Simple function total:", total1)

// Test 2: Nested function creation and calling
print("Test 2: Nested function calls")
mut total2 = 0
for i in 0..1000:
    total2 = total2 + make_math_function(i)
print("Math function total:", total2)

// Test 3: Complex nesting
print("Test 3: Complex nesting")
mut total3 = 0
for i in 0..1000:
    total3 = total3 + complex_nesting()
print("Complex nesting total:", total3)

// Test 4: Function object creation overhead
print("Test 4: Function overhead test")
mut total4 = 0
for i in 0..5000:
    fn local_func(x: i32) -> i32:
        x + i
    total4 = total4 + local_func(1)
print("Function overhead total:", total4)

end_time = time_stamp()
duration = end_time - start_time
duration_ms = duration / 1000000

print("=== Closure Infrastructure Benchmark Results ===")
print("Total time (nanoseconds):", duration)
print("Total time (milliseconds):", duration_ms)
print("Closure infrastructure benchmark completed")