// Closure benchmark for Orus - tests closure creation and invocation performance
// Note: Uses function-like syntax until closure syntax is implemented

// Test closure-like behavior with nested functions
fn make_counter_function() -> fn() -> i32:
    // This will be a closure when syntax is implemented
    mut count = 0
    fn increment() -> i32:
        count = count + 1
        count
    increment

// Test closure with multiple captures
fn make_adder_function(base: i32) -> fn(i32) -> i32:
    fn add_to_base(x: i32) -> i32:
        base + x
    add_to_base

// Test deep nesting (closure-like)
fn make_nested_function(a: i32) -> fn(i32) -> fn(i32) -> i32:
    fn level1(b: i32) -> fn(i32) -> i32:
        fn level2(c: i32) -> i32:
            a + b + c
        level2
    level1

// Test multiple function creation (closure overhead simulation)
fn create_multiple_functions() -> i32:
    mut total = 0
    
    for i in 0..100:
        fn local_func(x: i32) -> i32:
            x * 2
        total = total + local_func(i)
    
    total

print("=== Orus Closure Benchmark ===")

start_time = time_stamp()

// Test 1: Function creation and invocation
print("Test 1: Counter function creation")
counter = make_counter_function()
mut counter_total = 0
for i in 0..1000:
    counter_total = counter_total + counter()
print("Counter total:", counter_total)

// Test 2: Closure with captured value
print("Test 2: Adder function with capture")
add10 = make_adder_function(10)
mut adder_total = 0
for i in 0..1000:
    adder_total = adder_total + add10(i)
print("Adder total:", adder_total)

// Test 3: Nested function creation
print("Test 3: Nested function creation")
nested = make_nested_function(5)
mid = nested(10)
mut nested_total = 0
for i in 0..1000:
    nested_total = nested_total + mid(i)
print("Nested total:", nested_total)

// Test 4: Multiple function creation overhead
print("Test 4: Multiple function creation")
mut creation_total = 0
for i in 0..100:
    creation_total = creation_total + create_multiple_functions()
print("Creation total:", creation_total)

end_time = time_stamp()
duration = end_time - start_time
duration_ms = duration / 1000000

print("=== Closure Benchmark Results ===")
print("Total time (nanoseconds):", duration)
print("Total time (milliseconds):", duration_ms)
print("Closure benchmark completed")