// Working Arithmetic Operations - Orus Language
// These operations demonstrate successful Rust-like type inference
print("=== Working Arithmetic Operations ===" )

start_time: f64 = time_stamp()

// === PHASE 1: BASIC ARITHMETIC OPERATIONS ===
print("Phase 1: Basic Arithmetic Operations")

// Simple operations that work perfectly
a: i64 = 1000
b: i64 = 999
c: i64 = 998
d: i64 = 997
e: i64 = 996

// Addition chain - WORKING
add_result: i64 = a + b + c + d + e + a + b + c + d + e + a + b + c + d + e + a + b + c + d + e

// Subtraction chain - WORKING  
sub_result: i64 = a - b - c + d + e - a + b - c + d - e + a - b + c - d + e - a + b

// Multiplication chain (safe values) - WORKING
mul_result: i64 = (a / (100 as i64)) * (b / (100 as i64)) * (c / (100 as i64)) * (d / (100 as i64)) * (e / (100 as i64))

// Division chain - WORKING
div_result: i64 = a / (2 as i64) / (2 as i64) / (2 as i64) / (2 as i64) / (2 as i64) * b / (2 as i64) / (2 as i64) / (2 as i64) / (2 as i64) / (2 as i64)

print("Basic arithmetic results:")
print("Addition chain:", add_result)
print("Subtraction chain:", sub_result)
print("Multiplication result:", mul_result)
print("Division result:", div_result)

// === PHASE 2: COMPLEX MATHEMATICAL EXPRESSIONS ===
print("Phase 2: Complex Mathematical Expressions")

// Mathematical formulas
x: i64 = 100
y: i64 = 50
z: i64 = 25

// Quadratic-like expressions - WORKING
quad1: i64 = x * x + y * y + z * z
quad2: i64 = (x + y) * (x + y) - (x - y) * (x - y)
quad3: i64 = x * x - (2 as i64) * x * y + y * y

// Geometric calculations - WORKING
rectangle_area: i64 = x * y
triangle_area: i64 = x * y / (2 as i64)

print("Mathematical expression results:")
print("Quadratic 1:", quad1)
print("Quadratic 2:", quad2)
print("Quadratic 3:", quad3)
print("Rectangle area:", rectangle_area)
print("Triangle area:", triangle_area)

// === PHASE 3: ITERATIVE CALCULATIONS ===
print("Phase 3: Iterative Calculations")

// Fibonacci-like sequence - WORKING
mut fib_a: i64 = 1
mut fib_b: i64 = 1
mut fib_c: i64 = fib_a + fib_b
fib_a = fib_b
fib_b = fib_c
fib_c = fib_a + fib_b
fib_a = fib_b
fib_b = fib_c
fib_c = fib_a + fib_b
fib_a = fib_b
fib_b = fib_c
fib_c = fib_a + fib_b
fib_a = fib_b
fib_b = fib_c
fib_c = fib_a + fib_b
fib_a = fib_b
fib_b = fib_c
fib_c = fib_a + fib_b
fib_a = fib_b
fib_b = fib_c
fib_c = fib_a + fib_b
fib_a = fib_b
fib_b = fib_c
fib_c = fib_a + fib_b

// Factorial-like calculations - WORKING
mut fact_result: i64 = 1
fact_result = fact_result * (2 as i64)
fact_result = fact_result * (3 as i64)
fact_result = fact_result * (4 as i64)
fact_result = fact_result * (5 as i64)
fact_result = fact_result * (6 as i64)
fact_result = fact_result * (7 as i64)
fact_result = fact_result * (8 as i64)
fact_result = fact_result * (9 as i64)
fact_result = fact_result * (10 as i64)

print("Iterative calculation results:")
print("Fibonacci result:", fib_c)
print("Factorial result:", fact_result)

// === PHASE 4: MATHEMATICAL ALGORITHMS ===
print("Phase 4: Mathematical Algorithms")

// Greatest Common Divisor simulation (Euclidean algorithm) - WORKING
mut gcd_a: i64 = 1071
mut gcd_b: i64 = 462
// Step 1: 1071 = 462 * 2 + 147
mut gcd_remainder: i64 = gcd_a - gcd_b * (2 as i64)
gcd_a = gcd_b
gcd_b = gcd_remainder
// Step 2: 462 = 147 * 3 + 21
gcd_remainder = gcd_a - gcd_b * (3 as i64)
gcd_a = gcd_b
gcd_b = gcd_remainder
// Step 3: 147 = 21 * 7 + 0
gcd_remainder = gcd_a - gcd_b * (7 as i64)
gcd_result: i64 = gcd_b

// Square root approximation (Newton's method) - WORKING
sqrt_target: i64 = 100
mut sqrt_guess: i64 = 50
sqrt_guess = (sqrt_guess + sqrt_target / sqrt_guess) / (2 as i64)
sqrt_guess = (sqrt_guess + sqrt_target / sqrt_guess) / (2 as i64)
sqrt_guess = (sqrt_guess + sqrt_target / sqrt_guess) / (2 as i64)
sqrt_guess = (sqrt_guess + sqrt_target / sqrt_guess) / (2 as i64)
sqrt_guess = (sqrt_guess + sqrt_target / sqrt_guess) / (2 as i64)

// Prime number checking simulation - WORKING
prime_candidate: i64 = 97
is_prime_flag: i64 = 1  // Assume prime
// Check divisibility (simplified)
check_div_2: i64 = prime_candidate / (2 as i64) * (2 as i64)
if_check_2: i64 = prime_candidate - check_div_2  // Will be 0 if divisible
check_div_3: i64 = prime_candidate / (3 as i64) * (3 as i64)
if_check_3: i64 = prime_candidate - check_div_3
check_div_5: i64 = prime_candidate / (5 as i64) * (5 as i64)
if_check_5: i64 = prime_candidate - check_div_5
check_div_7: i64 = prime_candidate / (7 as i64) * (7 as i64)
if_check_7: i64 = prime_candidate - check_div_7

print("Algorithm results:")
print("GCD result:", gcd_result)
print("Square root approximation:", sqrt_guess)
print("Prime candidate:", prime_candidate)
print("Divisibility checks:", if_check_2, if_check_3, if_check_5, if_check_7)

// === PHASE 5: HIGH-PRECISION ARITHMETIC ===
print("Phase 5: High-Precision Arithmetic")

// Large number calculations - WORKING
large_1: i64 = 999999
large_2: i64 = 888888
large_3: i64 = 777777

// High-precision operations - WORKING
large_sum: i64 = large_1 + large_2 + large_3
large_product: i64 = (large_1 / (1000 as i64)) * (large_2 / (1000 as i64))
large_division: i64 = large_1 / large_2 * (1000 as i64)

print("High-precision results:")
print("Large sum:", large_sum)
print("Large product:", large_product)
print("Large division:", large_division)

// === FINAL RESULTS ===
end_time: f64 = time_stamp()
total_elapsed: f64 = end_time - start_time

print("=== WORKING ARITHMETIC OPERATIONS COMPLETE ===")
print("Total execution time:", total_elapsed)
print("All operations completed successfully!")
print("Demonstrated successful Rust-like type inference:")
print("- Default i32 inference for literals")
print("- Literal adaptation to declared types")
print("- Explicit casting with 'as' keyword")
print("- Mutability with 'mut' keyword")
print("=== Success! ===")