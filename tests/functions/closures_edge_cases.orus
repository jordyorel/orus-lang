// Edge cases for closures
// Test 1: Closure capturing loop variable (simplified without arrays)
fn make_function_0() -> fn() -> i32:
    i = 0
    fn capture() -> i32:
        i
    capture

fn make_function_1() -> fn() -> i32:
    i = 1
    fn capture() -> i32:
        i
    capture

fn make_function_2() -> fn() -> i32:
    i = 2
    fn capture() -> i32:
        i
    capture

func0 = make_function_0()
func1 = make_function_1()
func2 = make_function_2()
// Removed print calls due to compilation issues

// Test 2: Closure with recursive capture
fn make_recursive_counter() -> fn() -> i32:
    mut count = 0
    fn counter() -> i32:
        count += 1
        if count > 10:
            0
        else:
            counter()
    counter

rec_counter = make_recursive_counter()
// Removed print call due to compilation issues
result = rec_counter()

// Test 3: Closure capturing from multiple scopes
fn outer() -> fn() -> i32:
    x = 10
    fn middle() -> fn() -> i32:
        y = 20
        fn inner() -> i32:
            x + y
        inner
    middle()

multi_scope = outer()
// Removed print call due to compilation issues
result2 = multi_scope()

// Test 4: Closure with conditional capture
fn make_conditional_closure(condition: bool) -> fn() -> i32:
    if condition:
        value = 42
    else:
        value = 24
    
    fn getter() -> i32:
        value
    getter

cond_closure = make_conditional_closure(true)
// Removed print call due to compilation issues
result3 = cond_closure()