// Edge cases for recursive functions with tail call optimization

// Test 1: Simple recursive countdown
fn countdown(n: i32) -> i32:
    if n <= 0:
        0
    else:
        countdown(n - 1)

print("Testing simple recursive countdown:")
result1 = countdown(5)
print("Countdown result:", result1)

// Test 2: Factorial with tail call optimization
fn factorial_tail(n: i32, acc: i32) -> i32:
    if n <= 1:
        acc
    else:
        factorial_tail(n - 1, acc * n)

print("Testing tail-recursive factorial:")
result2 = factorial_tail(5, 1)
print("Factorial of 5:", result2)

// Test 3: Fibonacci with tail call optimization
fn fibonacci_tail(n: i32, a: i32, b: i32) -> i32:
    if n == 0:
        a
    else:
        fibonacci_tail(n - 1, b, a + b)

print("Testing tail-recursive fibonacci:")
result3 = fibonacci_tail(10, 0, 1)
print("Fibonacci of 10:", result3)

// Test 4: Mutual recursion (when supported)
fn is_even(n: i32) -> i32:
    if n == 0:
        1
    else:
        is_odd(n - 1)

fn is_odd(n: i32) -> i32:
    if n == 0:
        0
    else:
        is_even(n - 1)

print("Testing mutual recursion:")
result4 = is_even(4)
print("4 is even:", result4)

print("All recursive edge cases completed")